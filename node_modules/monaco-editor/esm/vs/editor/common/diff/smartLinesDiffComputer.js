import{LcsDiff}from"../../../base/common/diff/diff.js";import{LineRange,RangeMapping,LineRangeMapping}from"./linesDiffComputer.js";import*as strings from"../../../base/common/strings.js";import{Range}from"../core/range.js";import{assertFn,checkAdjacentItems}from"../../../base/common/assert.js";const MINIMUM_MATCHING_CHARACTER_LENGTH=3;export class SmartLinesDiffComputer{computeDiff(e,i,n){var t;const r=new DiffComputer(e,i,{maxComputationTime:n.maxComputationTimeMs,shouldIgnoreTrimWhitespace:n.ignoreTrimWhitespace,shouldComputeCharChanges:!0,shouldMakePrettyDiff:!0,shouldPostProcessCharChanges:!0}).computeDiff(),a=[];let s=null;for(const e of r.changes){let i,n;i=0===e.originalEndLineNumber?new LineRange(e.originalStartLineNumber+1,e.originalStartLineNumber+1):new LineRange(e.originalStartLineNumber,e.originalEndLineNumber+1),n=0===e.modifiedEndLineNumber?new LineRange(e.modifiedStartLineNumber+1,e.modifiedStartLineNumber+1):new LineRange(e.modifiedStartLineNumber,e.modifiedEndLineNumber+1);let r=new LineRangeMapping(i,n,null===(t=e.charChanges)||void 0===t?void 0:t.map((e=>new RangeMapping(new Range(e.originalStartLineNumber,e.originalStartColumn,e.originalEndLineNumber,e.originalEndColumn),new Range(e.modifiedStartLineNumber,e.modifiedStartColumn,e.modifiedEndLineNumber,e.modifiedEndColumn)))));s&&(s.modifiedRange.endLineNumberExclusive!==r.modifiedRange.startLineNumber&&s.originalRange.endLineNumberExclusive!==r.originalRange.startLineNumber||(r=new LineRangeMapping(s.originalRange.join(r.originalRange),s.modifiedRange.join(r.modifiedRange),s.innerChanges&&r.innerChanges?s.innerChanges.concat(r.innerChanges):void 0),a.pop())),a.push(r),s=r}return assertFn((()=>checkAdjacentItems(a,((e,i)=>i.originalRange.startLineNumber-e.originalRange.endLineNumberExclusive==i.modifiedRange.startLineNumber-e.modifiedRange.endLineNumberExclusive&&e.originalRange.endLineNumberExclusive<i.originalRange.startLineNumber&&e.modifiedRange.endLineNumberExclusive<i.modifiedRange.startLineNumber)))),{quitEarly:r.quitEarly,changes:a}}}function computeDiff(e,i,n,t){return new LcsDiff(e,i,n).ComputeDiff(t)}class LineSequence{constructor(e){const i=[],n=[];for(let t=0,r=e.length;t<r;t++)i[t]=getFirstNonBlankColumn(e[t],1),n[t]=getLastNonBlankColumn(e[t],1);this.lines=e,this._startColumns=i,this._endColumns=n}getElements(){const e=[];for(let i=0,n=this.lines.length;i<n;i++)e[i]=this.lines[i].substring(this._startColumns[i]-1,this._endColumns[i]-1);return e}getStrictElement(e){return this.lines[e]}getStartLineNumber(e){return e+1}getEndLineNumber(e){return e+1}createCharSequence(e,i,n){const t=[],r=[],a=[];let s=0;for(let o=i;o<=n;o++){const i=this.lines[o],h=e?this._startColumns[o]:1,g=e?this._endColumns[o]:i.length+1;for(let e=h;e<g;e++)t[s]=i.charCodeAt(e-1),r[s]=o+1,a[s]=e,s++;!e&&o<n&&(t[s]=10,r[s]=o+1,a[s]=i.length+1,s++)}return new CharSequence(t,r,a)}}class CharSequence{constructor(e,i,n){this._charCodes=e,this._lineNumbers=i,this._columns=n}toString(){return"["+this._charCodes.map(((e,i)=>(10===e?"\\n":String.fromCharCode(e))+`-(${this._lineNumbers[i]},${this._columns[i]})`)).join(", ")+"]"}_assertIndex(e,i){if(e<0||e>=i.length)throw new Error("Illegal index")}getElements(){return this._charCodes}getStartLineNumber(e){return e>0&&e===this._lineNumbers.length?this.getEndLineNumber(e-1):(this._assertIndex(e,this._lineNumbers),this._lineNumbers[e])}getEndLineNumber(e){return-1===e?this.getStartLineNumber(e+1):(this._assertIndex(e,this._lineNumbers),10===this._charCodes[e]?this._lineNumbers[e]+1:this._lineNumbers[e])}getStartColumn(e){return e>0&&e===this._columns.length?this.getEndColumn(e-1):(this._assertIndex(e,this._columns),this._columns[e])}getEndColumn(e){return-1===e?this.getStartColumn(e+1):(this._assertIndex(e,this._columns),10===this._charCodes[e]?1:this._columns[e]+1)}}class CharChange{constructor(e,i,n,t,r,a,s,o){this.originalStartLineNumber=e,this.originalStartColumn=i,this.originalEndLineNumber=n,this.originalEndColumn=t,this.modifiedStartLineNumber=r,this.modifiedStartColumn=a,this.modifiedEndLineNumber=s,this.modifiedEndColumn=o}static createFromDiffChange(e,i,n){const t=i.getStartLineNumber(e.originalStart),r=i.getStartColumn(e.originalStart),a=i.getEndLineNumber(e.originalStart+e.originalLength-1),s=i.getEndColumn(e.originalStart+e.originalLength-1),o=n.getStartLineNumber(e.modifiedStart),h=n.getStartColumn(e.modifiedStart),g=n.getEndLineNumber(e.modifiedStart+e.modifiedLength-1),m=n.getEndColumn(e.modifiedStart+e.modifiedLength-1);return new CharChange(t,r,a,s,o,h,g,m)}}function postProcessCharChanges(e){if(e.length<=1)return e;const i=[e[0]];let n=i[0];for(let t=1,r=e.length;t<r;t++){const r=e[t],a=r.originalStart-(n.originalStart+n.originalLength),s=r.modifiedStart-(n.modifiedStart+n.modifiedLength);Math.min(a,s)<3?(n.originalLength=r.originalStart+r.originalLength-n.originalStart,n.modifiedLength=r.modifiedStart+r.modifiedLength-n.modifiedStart):(i.push(r),n=r)}return i}class LineChange{constructor(e,i,n,t,r){this.originalStartLineNumber=e,this.originalEndLineNumber=i,this.modifiedStartLineNumber=n,this.modifiedEndLineNumber=t,this.charChanges=r}static createFromDiffResult(e,i,n,t,r,a,s){let o,h,g,m,u;if(0===i.originalLength?(o=n.getStartLineNumber(i.originalStart)-1,h=0):(o=n.getStartLineNumber(i.originalStart),h=n.getEndLineNumber(i.originalStart+i.originalLength-1)),0===i.modifiedLength?(g=t.getStartLineNumber(i.modifiedStart)-1,m=0):(g=t.getStartLineNumber(i.modifiedStart),m=t.getEndLineNumber(i.modifiedStart+i.modifiedLength-1)),a&&i.originalLength>0&&i.originalLength<20&&i.modifiedLength>0&&i.modifiedLength<20&&r()){const a=n.createCharSequence(e,i.originalStart,i.originalStart+i.originalLength-1),o=t.createCharSequence(e,i.modifiedStart,i.modifiedStart+i.modifiedLength-1);if(a.getElements().length>0&&o.getElements().length>0){let e=computeDiff(a,o,r,!0).changes;s&&(e=postProcessCharChanges(e)),u=[];for(let i=0,n=e.length;i<n;i++)u.push(CharChange.createFromDiffChange(e[i],a,o))}}return new LineChange(o,h,g,m,u)}}export class DiffComputer{constructor(e,i,n){this.shouldComputeCharChanges=n.shouldComputeCharChanges,this.shouldPostProcessCharChanges=n.shouldPostProcessCharChanges,this.shouldIgnoreTrimWhitespace=n.shouldIgnoreTrimWhitespace,this.shouldMakePrettyDiff=n.shouldMakePrettyDiff,this.originalLines=e,this.modifiedLines=i,this.original=new LineSequence(e),this.modified=new LineSequence(i),this.continueLineDiff=createContinueProcessingPredicate(n.maxComputationTime),this.continueCharDiff=createContinueProcessingPredicate(0===n.maxComputationTime?0:Math.min(n.maxComputationTime,5e3))}computeDiff(){if(1===this.original.lines.length&&0===this.original.lines[0].length)return 1===this.modified.lines.length&&0===this.modified.lines[0].length?{quitEarly:!1,changes:[]}:{quitEarly:!1,changes:[{originalStartLineNumber:1,originalEndLineNumber:1,modifiedStartLineNumber:1,modifiedEndLineNumber:this.modified.lines.length,charChanges:void 0}]};if(1===this.modified.lines.length&&0===this.modified.lines[0].length)return{quitEarly:!1,changes:[{originalStartLineNumber:1,originalEndLineNumber:this.original.lines.length,modifiedStartLineNumber:1,modifiedEndLineNumber:1,charChanges:void 0}]};const e=computeDiff(this.original,this.modified,this.continueLineDiff,this.shouldMakePrettyDiff),i=e.changes,n=e.quitEarly;if(this.shouldIgnoreTrimWhitespace){const e=[];for(let n=0,t=i.length;n<t;n++)e.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace,i[n],this.original,this.modified,this.continueCharDiff,this.shouldComputeCharChanges,this.shouldPostProcessCharChanges));return{quitEarly:n,changes:e}}const t=[];let r=0,a=0;for(let e=-1,n=i.length;e<n;e++){const s=e+1<n?i[e+1]:null,o=s?s.originalStart:this.originalLines.length,h=s?s.modifiedStart:this.modifiedLines.length;for(;r<o&&a<h;){const e=this.originalLines[r],i=this.modifiedLines[a];if(e!==i){{let n=getFirstNonBlankColumn(e,1),s=getFirstNonBlankColumn(i,1);for(;n>1&&s>1&&e.charCodeAt(n-2)===i.charCodeAt(s-2);)n--,s--;(n>1||s>1)&&this._pushTrimWhitespaceCharChange(t,r+1,1,n,a+1,1,s)}{let n=getLastNonBlankColumn(e,1),s=getLastNonBlankColumn(i,1);const o=e.length+1,h=i.length+1;for(;n<o&&s<h&&e.charCodeAt(n-1)===e.charCodeAt(s-1);)n++,s++;(n<o||s<h)&&this._pushTrimWhitespaceCharChange(t,r+1,n,o,a+1,s,h)}}r++,a++}s&&(t.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace,s,this.original,this.modified,this.continueCharDiff,this.shouldComputeCharChanges,this.shouldPostProcessCharChanges)),r+=s.originalLength,a+=s.modifiedLength)}return{quitEarly:n,changes:t}}_pushTrimWhitespaceCharChange(e,i,n,t,r,a,s){if(this._mergeTrimWhitespaceCharChange(e,i,n,t,r,a,s))return;let o;this.shouldComputeCharChanges&&(o=[new CharChange(i,n,i,t,r,a,r,s)]),e.push(new LineChange(i,i,r,r,o))}_mergeTrimWhitespaceCharChange(e,i,n,t,r,a,s){const o=e.length;if(0===o)return!1;const h=e[o-1];return 0!==h.originalEndLineNumber&&0!==h.modifiedEndLineNumber&&(h.originalEndLineNumber===i&&h.modifiedEndLineNumber===r?(this.shouldComputeCharChanges&&h.charChanges&&h.charChanges.push(new CharChange(i,n,i,t,r,a,r,s)),!0):h.originalEndLineNumber+1===i&&h.modifiedEndLineNumber+1===r&&(h.originalEndLineNumber=i,h.modifiedEndLineNumber=r,this.shouldComputeCharChanges&&h.charChanges&&h.charChanges.push(new CharChange(i,n,i,t,r,a,r,s)),!0))}}function getFirstNonBlankColumn(e,i){const n=strings.firstNonWhitespaceIndex(e);return-1===n?i:n+1}function getLastNonBlankColumn(e,i){const n=strings.lastNonWhitespaceIndex(e);return-1===n?i:n+2}function createContinueProcessingPredicate(e){if(0===e)return()=>!0;const i=Date.now();return()=>Date.now()-i<e}