import{assertFn,checkAdjacentItems}from"../../../base/common/assert.js";import{Position}from"../core/position.js";import{Range}from"../core/range.js";import{OffsetRange,SequenceDiff}from"./algorithms/diffAlgorithm.js";import{DynamicProgrammingDiffing}from"./algorithms/dynamicProgrammingDiffing.js";import{optimizeSequenceDiffs,smoothenSequenceDiffs}from"./algorithms/joinSequenceDiffs.js";import{MyersDiffAlgorithm}from"./algorithms/myersDiffAlgorithm.js";import{LineRange,LineRangeMapping,RangeMapping}from"./linesDiffComputer.js";export class StandardLinesDiffComputer{constructor(){this.dynamicProgrammingDiffing=new DynamicProgrammingDiffing,this.myersDiffingAlgorithm=new MyersDiffAlgorithm}computeDiff(e,n,t){const i=new Map;function r(e){let n=i.get(e);return void 0===n&&(n=i.size,i.set(e,n)),n}const s=e.map((e=>r(e.trim()))),o=n.map((e=>r(e.trim()))),a=new LineSequence(s,e),g=new LineSequence(o,n);let f=(()=>a.length+g.length<1500?this.dynamicProgrammingDiffing.compute(a,g,((t,i)=>e[t]===n[i]?0===n[i].length?.1:1+Math.log(1+n[i].length):.99)):this.myersDiffingAlgorithm.compute(a,g))();f=optimizeSequenceDiffs(a,g,f);const m=[],l=t=>{for(let i=0;i<t;i++){const t=c+i,r=u+i;if(e[t]!==n[r]){const i=this.refineDiff(e,n,new SequenceDiff(new OffsetRange(t,t+1),new OffsetRange(r,r+1)));for(const e of i)m.push(e)}}};let c=0,u=0;for(const t of f){assertFn((()=>t.seq1Range.start-c==t.seq2Range.start-u)),l(t.seq1Range.start-c),c=t.seq1Range.endExclusive,u=t.seq2Range.endExclusive;const i=this.refineDiff(e,n,t);for(const e of i)m.push(e)}return l(e.length-c),{quitEarly:!1,changes:lineRangeMappingFromRangeMappings(m)}}refineDiff(e,n,t){const i=new Slice(e,t.seq1Range),r=new Slice(n,t.seq2Range),s=i.length+r.length<500?this.dynamicProgrammingDiffing.compute(i,r):this.myersDiffingAlgorithm.compute(i,r);let o=optimizeSequenceDiffs(i,r,s);return o=smoothenSequenceDiffs(i,r,o),o.map((e=>new RangeMapping(i.translateRange(e.seq1Range).delta(t.seq1Range.start),r.translateRange(e.seq2Range).delta(t.seq2Range.start))))}}export function lineRangeMappingFromRangeMappings(e){const n=[];for(const t of group(e,((e,n)=>n.originalRange.startLineNumber-(e.originalRange.endLineNumber-(e.originalRange.endColumn>1?0:1))<=1||n.modifiedRange.startLineNumber-(e.modifiedRange.endLineNumber-(e.modifiedRange.endColumn>1?0:1))<=1))){const e=t[0],i=t[t.length-1];n.push(new LineRangeMapping(new LineRange(e.originalRange.startLineNumber,i.originalRange.endLineNumber+(i.originalRange.endColumn>1||i.modifiedRange.endColumn>1?1:0)),new LineRange(e.modifiedRange.startLineNumber,i.modifiedRange.endLineNumber+(i.originalRange.endColumn>1||i.modifiedRange.endColumn>1?1:0)),t))}return assertFn((()=>checkAdjacentItems(n,((e,n)=>n.originalRange.startLineNumber-e.originalRange.endLineNumberExclusive==n.modifiedRange.startLineNumber-e.modifiedRange.endLineNumberExclusive&&e.originalRange.endLineNumberExclusive<n.originalRange.startLineNumber&&e.modifiedRange.endLineNumberExclusive<n.modifiedRange.startLineNumber)))),n}function*group(e,n){let t,i;for(const r of e)void 0!==i&&n(i,r)?t.push(r):(t&&(yield t),t=[r]),i=r;t&&(yield t)}export class LineSequence{constructor(e,n){this.trimmedHash=e,this.lines=n}getElement(e){return this.trimmedHash[e]}get length(){return this.trimmedHash.length}getBoundaryScore(e){return 1e3-((0===e?0:getIndentation(this.lines[e-1]))+(e===this.lines.length?0:getIndentation(this.lines[e])))}}function getIndentation(e){let n=0;for(;n<e.length&&(32===e.charCodeAt(n)||9===e.charCodeAt(n));)n++;return n}class Slice{constructor(e,n){this.lines=e,this.lineRange=n;let t=0;this.firstCharOnLineOffsets=new Int32Array(n.length);for(let i=n.start;i<n.endExclusive;i++)t+=e[i].length,this.firstCharOnLineOffsets[i-n.start]=t+1,t++;this.elements=new Int32Array(t);let i=0;for(let t=n.start;t<n.endExclusive;t++){const n=e[t];for(let e=0;e<n.length;e++)this.elements[i+e]=n.charCodeAt(e);i+=n.length,t<e.length-1&&(this.elements[i]="\n".charCodeAt(0),i+=1)}}getElement(e){return this.elements[e]}get length(){return this.elements.length}getBoundaryScore(e){const n=getCategory(e>0?this.elements[e-1]:-1),t=getCategory(e<this.elements.length?this.elements[e]:-1);if(6===n&&7===t)return 0;let i=0;return n!==t&&(i+=10,1===t&&(i+=1)),i+=getCategoryBoundaryScore(n),i+=getCategoryBoundaryScore(t),i}translateOffset(e){let n=0,t=this.firstCharOnLineOffsets.length;for(;n<t;){const i=Math.floor((n+t)/2);this.firstCharOnLineOffsets[i]>e?t=i:n=i+1}const i=0===n?0:this.firstCharOnLineOffsets[n-1];return new Position(n+1,e-i+1)}translateRange(e){return Range.fromPositions(this.translateOffset(e.start),this.translateOffset(e.endExclusive))}}const score={0:0,1:0,2:0,3:10,4:2,5:3,6:10,7:10};function getCategoryBoundaryScore(e){return score[e]}function getCategory(e){return 10===e?7:13===e?6:isSpace(e)?5:e>=97&&e<=122?0:e>=65&&e<=90?1:e>=48&&e<=57?2:-1===e?3:4}function isSpace(e){return 32===e||9===e}