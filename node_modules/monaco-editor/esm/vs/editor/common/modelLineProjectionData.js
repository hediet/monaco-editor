import{assertNever}from"../../base/common/assert.js";import{Position}from"./core/position.js";import{InjectedTextCursorStops}from"./model.js";export class ModelLineProjectionData{constructor(t,e,n,i,s){this.injectionOffsets=t,this.injectionOptions=e,this.breakOffsets=n,this.breakOffsetsVisibleColumn=i,this.wrappedTextIndentLength=s}getOutputLineCount(){return this.breakOffsets.length}getMinOutputOffset(t){return t>0?this.wrappedTextIndentLength:0}getLineLength(t){const e=t>0?this.breakOffsets[t-1]:0;let n=this.breakOffsets[t]-e;return t>0&&(n+=this.wrappedTextIndentLength),n}getMaxOutputOffset(t){return this.getLineLength(t)}translateToInputOffset(t,e){t>0&&(e=Math.max(0,e-this.wrappedTextIndentLength));let n=0===t?e:this.breakOffsets[t-1]+e;if(null!==this.injectionOffsets)for(let t=0;t<this.injectionOffsets.length&&n>this.injectionOffsets[t];t++)n<this.injectionOffsets[t]+this.injectionOptions[t].content.length?n=this.injectionOffsets[t]:n-=this.injectionOptions[t].content.length;return n}translateToOutputPosition(t,e=2){let n=t;if(null!==this.injectionOffsets)for(let i=0;i<this.injectionOffsets.length&&!(t<this.injectionOffsets[i])&&(1===e||t!==this.injectionOffsets[i]);i++)n+=this.injectionOptions[i].content.length;return this.offsetInInputWithInjectionsToOutputPosition(n,e)}offsetInInputWithInjectionsToOutputPosition(t,e=2){let n=0,i=this.breakOffsets.length-1,s=0,o=0;for(;n<=i;){s=n+(i-n)/2|0;const f=this.breakOffsets[s];if(o=s>0?this.breakOffsets[s-1]:0,0===e)if(t<=o)i=s-1;else{if(!(t>f))break;n=s+1}else if(t<o)i=s-1;else{if(!(t>=f))break;n=s+1}}let f=t-o;return s>0&&(f+=this.wrappedTextIndentLength),new OutputPosition(s,f)}normalizeOutputPosition(t,e,n){if(null!==this.injectionOffsets){const i=this.outputPositionToOffsetInInputWithInjections(t,e),s=this.normalizeOffsetInInputWithInjectionsAroundInjections(i,n);if(s!==i)return this.offsetInInputWithInjectionsToOutputPosition(s,n)}if(0===n){if(t>0&&e===this.getMinOutputOffset(t))return new OutputPosition(t-1,this.getMaxOutputOffset(t-1))}else if(1===n&&t<this.getOutputLineCount()-1&&e===this.getMaxOutputOffset(t))return new OutputPosition(t+1,this.getMinOutputOffset(t+1));return new OutputPosition(t,e)}outputPositionToOffsetInInputWithInjections(t,e){return t>0&&(e=Math.max(0,e-this.wrappedTextIndentLength)),(t>0?this.breakOffsets[t-1]:0)+e}normalizeOffsetInInputWithInjectionsAroundInjections(t,e){const n=this.getInjectedTextAtOffset(t);if(!n)return t;if(2===e){if(t===n.offsetInInputWithInjections+n.length&&hasRightCursorStop(this.injectionOptions[n.injectedTextIndex].cursorStops))return n.offsetInInputWithInjections+n.length;{let t=n.offsetInInputWithInjections;if(hasLeftCursorStop(this.injectionOptions[n.injectedTextIndex].cursorStops))return t;let e=n.injectedTextIndex-1;for(;e>=0&&this.injectionOffsets[e]===this.injectionOffsets[n.injectedTextIndex]&&!hasRightCursorStop(this.injectionOptions[e].cursorStops)&&(t-=this.injectionOptions[e].content.length,!hasLeftCursorStop(this.injectionOptions[e].cursorStops));)e--;return t}}if(1===e||4===e){let t=n.offsetInInputWithInjections+n.length,e=n.injectedTextIndex;for(;e+1<this.injectionOffsets.length&&this.injectionOffsets[e+1]===this.injectionOffsets[e];)t+=this.injectionOptions[e+1].content.length,e++;return t}if(0===e||3===e){let t=n.offsetInInputWithInjections,e=n.injectedTextIndex;for(;e-1>=0&&this.injectionOffsets[e-1]===this.injectionOffsets[e];)t-=this.injectionOptions[e-1].content.length,e--;return t}assertNever(e)}getInjectedText(t,e){const n=this.outputPositionToOffsetInInputWithInjections(t,e),i=this.getInjectedTextAtOffset(n);return i?{options:this.injectionOptions[i.injectedTextIndex]}:null}getInjectedTextAtOffset(t){const e=this.injectionOffsets,n=this.injectionOptions;if(null!==e){let i=0;for(let s=0;s<e.length;s++){const o=n[s].content.length,f=e[s]+i,r=e[s]+i+o;if(f>t)break;if(t<=r)return{injectedTextIndex:s,offsetInInputWithInjections:f,length:o};i+=o}}}}function hasRightCursorStop(t){return null==t||t===InjectedTextCursorStops.Right||t===InjectedTextCursorStops.Both}function hasLeftCursorStop(t){return null==t||t===InjectedTextCursorStops.Left||t===InjectedTextCursorStops.Both}export class InjectedText{constructor(t){this.options=t}}export class OutputPosition{constructor(t,e){this.outputLineIndex=t,this.outputOffset=e}toString(){return`${this.outputLineIndex}:${this.outputOffset}`}toPosition(t){return new Position(t+this.outputLineIndex,this.outputOffset+1)}}