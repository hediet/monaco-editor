import*as strings from"../../../base/common/strings.js";import{ReplaceCommand}from"../commands/replaceCommand.js";import{EditOperationResult,isQuote}from"../cursorCommon.js";import{CursorColumns}from"../core/cursorColumns.js";import{MoveOperations}from"./cursorMoveOperations.js";import{Range}from"../core/range.js";import{Position}from"../core/position.js";export class DeleteOperations{static deleteRight(e,t,n,o){const i=[];let r=3!==e;for(let e=0,l=o.length;e<l;e++){const l=o[e];let s=l;if(s.isEmpty()){const e=l.getPosition(),o=MoveOperations.right(t,n,e);s=new Range(o.lineNumber,o.column,e.lineNumber,e.column)}s.isEmpty()?i[e]=null:(s.startLineNumber!==s.endLineNumber&&(r=!0),i[e]=new ReplaceCommand(s,""))}return[r,i]}static isAutoClosingPairDelete(e,t,n,o,i,r,l){if("never"===t&&"never"===n)return!1;if("never"===e)return!1;for(let s=0,u=r.length;s<u;s++){const u=r[s],m=u.getPosition();if(!u.isEmpty())return!1;const a=i.getLineContent(m.lineNumber);if(m.column<2||m.column>=a.length+1)return!1;const c=a.charAt(m.column-2),g=o.get(c);if(!g)return!1;if(isQuote(c)){if("never"===n)return!1}else if("never"===t)return!1;const f=a.charAt(m.column-1);let p=!1;for(const e of g)e.open===c&&e.close===f&&(p=!0);if(!p)return!1;if("auto"===e){let e=!1;for(let t=0,n=l.length;t<n;t++){const n=l[t];if(m.lineNumber===n.startLineNumber&&m.column===n.startColumn){e=!0;break}}if(!e)return!1}}return!0}static _runAutoClosingPairDelete(e,t,n){const o=[];for(let e=0,t=n.length;e<t;e++){const t=n[e].getPosition(),i=new Range(t.lineNumber,t.column-1,t.lineNumber,t.column+1);o[e]=new ReplaceCommand(i,"")}return[!0,o]}static deleteLeft(e,t,n,o,i){if(this.isAutoClosingPairDelete(t.autoClosingDelete,t.autoClosingBrackets,t.autoClosingQuotes,t.autoClosingPairs.autoClosingPairsOpenByEnd,n,o,i))return this._runAutoClosingPairDelete(t,n,o);const r=[];let l=2!==e;for(let e=0,i=o.length;e<i;e++){const i=DeleteOperations.getDeleteRange(o[e],n,t);i.isEmpty()?r[e]=null:(i.startLineNumber!==i.endLineNumber&&(l=!0),r[e]=new ReplaceCommand(i,""))}return[l,r]}static getDeleteRange(e,t,n){if(!e.isEmpty())return e;const o=e.getPosition();if(n.useTabStops&&o.column>1){const e=t.getLineContent(o.lineNumber),i=strings.firstNonWhitespaceIndex(e),r=-1===i?e.length+1:i+1;if(o.column<=r){const e=n.visibleColumnFromColumn(t,o),i=CursorColumns.prevIndentTabStop(e,n.indentSize),r=n.columnFromVisibleColumn(t,o.lineNumber,i);return new Range(o.lineNumber,r,o.lineNumber,o.column)}}return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(o,t),o)}static getPositionAfterDeleteLeft(e,t){if(e.column>1){const n=strings.getLeftDeleteOffset(e.column-1,t.getLineContent(e.lineNumber));return e.with(void 0,n+1)}if(e.lineNumber>1){const n=e.lineNumber-1;return new Position(n,t.getLineMaxColumn(n))}return e}static cut(e,t,n){const o=[];let i=null;n.sort(((e,t)=>Position.compare(e.getStartPosition(),t.getEndPosition())));for(let r=0,l=n.length;r<l;r++){const l=n[r];if(l.isEmpty())if(e.emptySelectionClipboard){const e=l.getPosition();let n,s,u,m;e.lineNumber<t.getLineCount()?(n=e.lineNumber,s=1,u=e.lineNumber+1,m=1):e.lineNumber>1&&(null==i?void 0:i.endLineNumber)!==e.lineNumber?(n=e.lineNumber-1,s=t.getLineMaxColumn(e.lineNumber-1),u=e.lineNumber,m=t.getLineMaxColumn(e.lineNumber)):(n=e.lineNumber,s=1,u=e.lineNumber,m=t.getLineMaxColumn(e.lineNumber));const a=new Range(n,s,u,m);i=a,a.isEmpty()?o[r]=null:o[r]=new ReplaceCommand(a,"")}else o[r]=null;else o[r]=new ReplaceCommand(l,"")}return new EditOperationResult(0,o,{shouldPushStackElementBefore:!0,shouldPushStackElementAfter:!0})}}