import{SingleCursorState}from"../cursorCommon.js";import{CursorColumns}from"../core/cursorColumns.js";import{Position}from"../core/position.js";import{Range}from"../core/range.js";import*as strings from"../../../base/common/strings.js";import{AtomicTabMoveOperations}from"./cursorAtomicMoveOperations.js";export class CursorPosition{constructor(e,n,o){this._cursorPositionBrand=void 0,this.lineNumber=e,this.column=n,this.leftoverVisibleColumns=o}}export class MoveOperations{static leftPosition(e,n){if(n.column>e.getLineMinColumn(n.lineNumber))return n.delta(void 0,-strings.prevCharLength(e.getLineContent(n.lineNumber),n.column-1));if(n.lineNumber>1){const o=n.lineNumber-1;return new Position(o,e.getLineMaxColumn(o))}return n}static leftPositionAtomicSoftTabs(e,n,o){if(n.column<=e.getLineIndentColumn(n.lineNumber)){const i=e.getLineMinColumn(n.lineNumber),t=e.getLineContent(n.lineNumber),s=AtomicTabMoveOperations.atomicPosition(t,n.column-1,o,0);if(-1!==s&&s+1>=i)return new Position(n.lineNumber,s+1)}return this.leftPosition(e,n)}static left(e,n,o){const i=e.stickyTabStops?MoveOperations.leftPositionAtomicSoftTabs(n,o,e.tabSize):MoveOperations.leftPosition(n,o);return new CursorPosition(i.lineNumber,i.column,0)}static moveLeft(e,n,o,i,t){let s,r;if(o.hasSelection()&&!i)s=o.selection.startLineNumber,r=o.selection.startColumn;else{const i=o.position.delta(void 0,-(t-1)),l=n.normalizePosition(MoveOperations.clipPositionColumn(i,n),0),m=MoveOperations.left(e,n,l);s=m.lineNumber,r=m.column}return o.move(i,s,r,0)}static clipPositionColumn(e,n){return new Position(e.lineNumber,MoveOperations.clipRange(e.column,n.getLineMinColumn(e.lineNumber),n.getLineMaxColumn(e.lineNumber)))}static clipRange(e,n,o){return e<n?n:e>o?o:e}static rightPosition(e,n,o){return o<e.getLineMaxColumn(n)?o+=strings.nextCharLength(e.getLineContent(n),o-1):n<e.getLineCount()&&(n+=1,o=e.getLineMinColumn(n)),new Position(n,o)}static rightPositionAtomicSoftTabs(e,n,o,i,t){if(o<e.getLineIndentColumn(n)){const t=e.getLineContent(n),s=AtomicTabMoveOperations.atomicPosition(t,o-1,i,1);if(-1!==s)return new Position(n,s+1)}return this.rightPosition(e,n,o)}static right(e,n,o){const i=e.stickyTabStops?MoveOperations.rightPositionAtomicSoftTabs(n,o.lineNumber,o.column,e.tabSize,e.indentSize):MoveOperations.rightPosition(n,o.lineNumber,o.column);return new CursorPosition(i.lineNumber,i.column,0)}static moveRight(e,n,o,i,t){let s,r;if(o.hasSelection()&&!i)s=o.selection.endLineNumber,r=o.selection.endColumn;else{const i=o.position.delta(void 0,t-1),l=n.normalizePosition(MoveOperations.clipPositionColumn(i,n),1),m=MoveOperations.right(e,n,l);s=m.lineNumber,r=m.column}return o.move(i,s,r,0)}static vertical(e,n,o,i,t,s,r,l){const m=CursorColumns.visibleColumnFromColumn(n.getLineContent(o),i,e.tabSize)+t,u=n.getLineCount(),a=1===o&&1===i,c=o===u&&i===n.getLineMaxColumn(o),C=s<o?a:c;if((o=s)<1?(o=1,i=r?n.getLineMinColumn(o):Math.min(n.getLineMaxColumn(o),i)):o>u?(o=u,i=r?n.getLineMaxColumn(o):Math.min(n.getLineMaxColumn(o),i)):i=e.columnFromVisibleColumn(n,o,m),t=C?0:m-CursorColumns.visibleColumnFromColumn(n.getLineContent(o),i,e.tabSize),void 0!==l){const e=new Position(o,i),s=n.normalizePosition(e,l);t+=i-s.column,o=s.lineNumber,i=s.column}return new CursorPosition(o,i,t)}static down(e,n,o,i,t,s,r){return this.vertical(e,n,o,i,t,o+s,r,4)}static moveDown(e,n,o,i,t){let s,r;o.hasSelection()&&!i?(s=o.selection.endLineNumber,r=o.selection.endColumn):(s=o.position.lineNumber,r=o.position.column);const l=MoveOperations.down(e,n,s,r,o.leftoverVisibleColumns,t,!0);return o.move(i,l.lineNumber,l.column,l.leftoverVisibleColumns)}static translateDown(e,n,o){const i=o.selection,t=MoveOperations.down(e,n,i.selectionStartLineNumber,i.selectionStartColumn,o.selectionStartLeftoverVisibleColumns,1,!1),s=MoveOperations.down(e,n,i.positionLineNumber,i.positionColumn,o.leftoverVisibleColumns,1,!1);return new SingleCursorState(new Range(t.lineNumber,t.column,t.lineNumber,t.column),0,t.leftoverVisibleColumns,new Position(s.lineNumber,s.column),s.leftoverVisibleColumns)}static up(e,n,o,i,t,s,r){return this.vertical(e,n,o,i,t,o-s,r,3)}static moveUp(e,n,o,i,t){let s,r;o.hasSelection()&&!i?(s=o.selection.startLineNumber,r=o.selection.startColumn):(s=o.position.lineNumber,r=o.position.column);const l=MoveOperations.up(e,n,s,r,o.leftoverVisibleColumns,t,!0);return o.move(i,l.lineNumber,l.column,l.leftoverVisibleColumns)}static translateUp(e,n,o){const i=o.selection,t=MoveOperations.up(e,n,i.selectionStartLineNumber,i.selectionStartColumn,o.selectionStartLeftoverVisibleColumns,1,!1),s=MoveOperations.up(e,n,i.positionLineNumber,i.positionColumn,o.leftoverVisibleColumns,1,!1);return new SingleCursorState(new Range(t.lineNumber,t.column,t.lineNumber,t.column),0,t.leftoverVisibleColumns,new Position(s.lineNumber,s.column),s.leftoverVisibleColumns)}static _isBlankLine(e,n){return 0===e.getLineFirstNonWhitespaceColumn(n)}static moveToPrevBlankLine(e,n,o,i){let t=o.position.lineNumber;for(;t>1&&this._isBlankLine(n,t);)t--;for(;t>1&&!this._isBlankLine(n,t);)t--;return o.move(i,t,n.getLineMinColumn(t),0)}static moveToNextBlankLine(e,n,o,i){const t=n.getLineCount();let s=o.position.lineNumber;for(;s<t&&this._isBlankLine(n,s);)s++;for(;s<t&&!this._isBlankLine(n,s);)s++;return o.move(i,s,n.getLineMinColumn(s),0)}static moveToBeginningOfLine(e,n,o,i){const t=o.position.lineNumber,s=n.getLineMinColumn(t),r=n.getLineFirstNonWhitespaceColumn(t)||s;let l;return l=o.position.column===r?s:r,o.move(i,t,l,0)}static moveToEndOfLine(e,n,o,i,t){const s=o.position.lineNumber,r=n.getLineMaxColumn(s);return o.move(i,s,r,t?1073741824-r:0)}static moveToBeginningOfBuffer(e,n,o,i){return o.move(i,1,1,0)}static moveToEndOfBuffer(e,n,o,i){const t=n.getLineCount(),s=n.getLineMaxColumn(t);return o.move(i,t,s,0)}}