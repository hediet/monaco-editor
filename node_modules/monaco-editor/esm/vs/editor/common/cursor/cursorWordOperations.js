import*as strings from"../../../base/common/strings.js";import{SingleCursorState}from"../cursorCommon.js";import{DeleteOperations}from"./cursorDeleteOperations.js";import{getMapForWordSeparators}from"../core/wordCharacterClassifier.js";import{Position}from"../core/position.js";import{Range}from"../core/range.js";export class WordOperations{static _createWord(e,t,n,r,i){return{start:r,end:i,wordType:t,nextCharClass:n}}static _findPreviousWordOnLine(e,t,n){const r=t.getLineContent(n.lineNumber);return this._doFindPreviousWordOnLine(r,e,n)}static _doFindPreviousWordOnLine(e,t,n){let r=0;for(let i=n.column-2;i>=0;i--){const n=e.charCodeAt(i),o=t.get(n);if(0===o){if(2===r)return this._createWord(e,r,o,i+1,this._findEndOfWord(e,t,r,i+1));r=1}else if(2===o){if(1===r)return this._createWord(e,r,o,i+1,this._findEndOfWord(e,t,r,i+1));r=2}else if(1===o&&0!==r)return this._createWord(e,r,o,i+1,this._findEndOfWord(e,t,r,i+1))}return 0!==r?this._createWord(e,r,1,0,this._findEndOfWord(e,t,r,0)):null}static _findEndOfWord(e,t,n,r){const i=e.length;for(let o=r;o<i;o++){const r=e.charCodeAt(o),i=t.get(r);if(1===i)return o;if(1===n&&2===i)return o;if(2===n&&0===i)return o}return i}static _findNextWordOnLine(e,t,n){const r=t.getLineContent(n.lineNumber);return this._doFindNextWordOnLine(r,e,n)}static _doFindNextWordOnLine(e,t,n){let r=0;const i=e.length;for(let o=n.column-1;o<i;o++){const n=e.charCodeAt(o),i=t.get(n);if(0===i){if(2===r)return this._createWord(e,r,i,this._findStartOfWord(e,t,r,o-1),o);r=1}else if(2===i){if(1===r)return this._createWord(e,r,i,this._findStartOfWord(e,t,r,o-1),o);r=2}else if(1===i&&0!==r)return this._createWord(e,r,i,this._findStartOfWord(e,t,r,o-1),o)}return 0!==r?this._createWord(e,r,1,this._findStartOfWord(e,t,r,i-1),i):null}static _findStartOfWord(e,t,n,r){for(let i=r;i>=0;i--){const r=e.charCodeAt(i),o=t.get(r);if(1===o)return i+1;if(1===n&&2===o)return i+1;if(2===n&&0===o)return i+1}return 0}static moveWordLeft(e,t,n,r){let i=n.lineNumber,o=n.column;1===o&&i>1&&(i-=1,o=t.getLineMaxColumn(i));let s=WordOperations._findPreviousWordOnLine(e,t,new Position(i,o));if(0===r)return new Position(i,s?s.start+1:1);if(1===r)return s&&2===s.wordType&&s.end-s.start==1&&0===s.nextCharClass&&(s=WordOperations._findPreviousWordOnLine(e,t,new Position(i,s.start+1))),new Position(i,s?s.start+1:1);if(3===r){for(;s&&2===s.wordType;)s=WordOperations._findPreviousWordOnLine(e,t,new Position(i,s.start+1));return new Position(i,s?s.start+1:1)}return s&&o<=s.end+1&&(s=WordOperations._findPreviousWordOnLine(e,t,new Position(i,s.start+1))),new Position(i,s?s.end+1:1)}static _moveWordPartLeft(e,t){const n=t.lineNumber,r=e.getLineMaxColumn(n);if(1===t.column)return n>1?new Position(n-1,e.getLineMaxColumn(n-1)):t;const i=e.getLineContent(n);for(let e=t.column-1;e>1;e--){const t=i.charCodeAt(e-2),o=i.charCodeAt(e-1);if(95===t&&95!==o)return new Position(n,e);if(45===t&&45!==o)return new Position(n,e);if((strings.isLowerAsciiLetter(t)||strings.isAsciiDigit(t))&&strings.isUpperAsciiLetter(o))return new Position(n,e);if(strings.isUpperAsciiLetter(t)&&strings.isUpperAsciiLetter(o)&&e+1<r){const t=i.charCodeAt(e);if(strings.isLowerAsciiLetter(t)||strings.isAsciiDigit(t))return new Position(n,e)}}return new Position(n,1)}static moveWordRight(e,t,n,r){let i=n.lineNumber,o=n.column,s=!1;o===t.getLineMaxColumn(i)&&i<t.getLineCount()&&(s=!0,i+=1,o=1);let a=WordOperations._findNextWordOnLine(e,t,new Position(i,o));if(2===r)a&&2===a.wordType&&a.end-a.start==1&&0===a.nextCharClass&&(a=WordOperations._findNextWordOnLine(e,t,new Position(i,a.end+1))),o=a?a.end+1:t.getLineMaxColumn(i);else if(3===r){for(s&&(o=0);a&&(2===a.wordType||a.start+1<=o);)a=WordOperations._findNextWordOnLine(e,t,new Position(i,a.end+1));o=a?a.start+1:t.getLineMaxColumn(i)}else a&&!s&&o>=a.start+1&&(a=WordOperations._findNextWordOnLine(e,t,new Position(i,a.end+1))),o=a?a.start+1:t.getLineMaxColumn(i);return new Position(i,o)}static _moveWordPartRight(e,t){const n=t.lineNumber,r=e.getLineMaxColumn(n);if(t.column===r)return n<e.getLineCount()?new Position(n+1,1):t;const i=e.getLineContent(n);for(let e=t.column+1;e<r;e++){const t=i.charCodeAt(e-2),o=i.charCodeAt(e-1);if(95!==t&&95===o)return new Position(n,e);if(45!==t&&45===o)return new Position(n,e);if((strings.isLowerAsciiLetter(t)||strings.isAsciiDigit(t))&&strings.isUpperAsciiLetter(o))return new Position(n,e);if(strings.isUpperAsciiLetter(t)&&strings.isUpperAsciiLetter(o)&&e+1<r){const t=i.charCodeAt(e);if(strings.isLowerAsciiLetter(t)||strings.isAsciiDigit(t))return new Position(n,e)}}return new Position(n,r)}static _deleteWordLeftWhitespace(e,t){const n=e.getLineContent(t.lineNumber),r=t.column-2,i=strings.lastNonWhitespaceIndex(n,r);return i+1<r?new Range(t.lineNumber,i+2,t.lineNumber,t.column):null}static deleteWordLeft(e,t){const n=e.wordSeparators,r=e.model,i=e.selection,o=e.whitespaceHeuristics;if(!i.isEmpty())return i;if(DeleteOperations.isAutoClosingPairDelete(e.autoClosingDelete,e.autoClosingBrackets,e.autoClosingQuotes,e.autoClosingPairs.autoClosingPairsOpenByEnd,e.model,[e.selection],e.autoClosedCharacters)){const t=e.selection.getPosition();return new Range(t.lineNumber,t.column-1,t.lineNumber,t.column+1)}const s=new Position(i.positionLineNumber,i.positionColumn);let a=s.lineNumber,d=s.column;if(1===a&&1===d)return null;if(o){const e=this._deleteWordLeftWhitespace(r,s);if(e)return e}let l=WordOperations._findPreviousWordOnLine(n,r,s);return 0===t?l?d=l.start+1:d>1?d=1:(a--,d=r.getLineMaxColumn(a)):(l&&d<=l.end+1&&(l=WordOperations._findPreviousWordOnLine(n,r,new Position(a,l.start+1))),l?d=l.end+1:d>1?d=1:(a--,d=r.getLineMaxColumn(a))),new Range(a,d,s.lineNumber,s.column)}static deleteInsideWord(e,t,n){if(!n.isEmpty())return n;const r=new Position(n.positionLineNumber,n.positionColumn);return this._deleteInsideWordWhitespace(t,r)||this._deleteInsideWordDetermineDeleteRange(e,t,r)}static _charAtIsWhitespace(e,t){const n=e.charCodeAt(t);return 32===n||9===n}static _deleteInsideWordWhitespace(e,t){const n=e.getLineContent(t.lineNumber),r=n.length;if(0===r)return null;let i=Math.max(t.column-2,0);if(!this._charAtIsWhitespace(n,i))return null;let o=Math.min(t.column-1,r-1);if(!this._charAtIsWhitespace(n,o))return null;for(;i>0&&this._charAtIsWhitespace(n,i-1);)i--;for(;o+1<r&&this._charAtIsWhitespace(n,o+1);)o++;return new Range(t.lineNumber,i+1,t.lineNumber,o+2)}static _deleteInsideWordDetermineDeleteRange(e,t,n){const r=t.getLineContent(n.lineNumber),i=r.length;if(0===i)return n.lineNumber>1?new Range(n.lineNumber-1,t.getLineMaxColumn(n.lineNumber-1),n.lineNumber,1):n.lineNumber<t.getLineCount()?new Range(n.lineNumber,1,n.lineNumber+1,1):new Range(n.lineNumber,1,n.lineNumber,1);const o=e=>e.start+1<=n.column&&n.column<=e.end+1,s=(e,t)=>(e=Math.min(e,n.column),t=Math.max(t,n.column),new Range(n.lineNumber,e,n.lineNumber,t)),a=e=>{let t=e.start+1,n=e.end+1,o=!1;for(;n-1<i&&this._charAtIsWhitespace(r,n-1);)o=!0,n++;if(!o)for(;t>1&&this._charAtIsWhitespace(r,t-2);)t--;return s(t,n)},d=WordOperations._findPreviousWordOnLine(e,t,n);if(d&&o(d))return a(d);const l=WordOperations._findNextWordOnLine(e,t,n);return l&&o(l)?a(l):d&&l?s(d.end+1,l.start+1):d?s(d.start+1,d.end+1):l?s(l.start+1,l.end+1):s(1,i+1)}static _deleteWordPartLeft(e,t){if(!t.isEmpty())return t;const n=t.getPosition(),r=WordOperations._moveWordPartLeft(e,n);return new Range(n.lineNumber,n.column,r.lineNumber,r.column)}static _findFirstNonWhitespaceChar(e,t){const n=e.length;for(let r=t;r<n;r++){const t=e.charAt(r);if(" "!==t&&"\t"!==t)return r}return n}static _deleteWordRightWhitespace(e,t){const n=e.getLineContent(t.lineNumber),r=t.column-1,i=this._findFirstNonWhitespaceChar(n,r);return r+1<i?new Range(t.lineNumber,t.column,t.lineNumber,i+1):null}static deleteWordRight(e,t){const n=e.wordSeparators,r=e.model,i=e.selection,o=e.whitespaceHeuristics;if(!i.isEmpty())return i;const s=new Position(i.positionLineNumber,i.positionColumn);let a=s.lineNumber,d=s.column;const l=r.getLineCount(),u=r.getLineMaxColumn(a);if(a===l&&d===u)return null;if(o){const e=this._deleteWordRightWhitespace(r,s);if(e)return e}let c=WordOperations._findNextWordOnLine(n,r,s);return 2===t?c?d=c.end+1:d<u||a===l?d=u:(a++,c=WordOperations._findNextWordOnLine(n,r,new Position(a,1)),d=c?c.start+1:r.getLineMaxColumn(a)):(c&&d>=c.start+1&&(c=WordOperations._findNextWordOnLine(n,r,new Position(a,c.end+1))),c?d=c.start+1:d<u||a===l?d=u:(a++,c=WordOperations._findNextWordOnLine(n,r,new Position(a,1)),d=c?c.start+1:r.getLineMaxColumn(a))),new Range(a,d,s.lineNumber,s.column)}static _deleteWordPartRight(e,t){if(!t.isEmpty())return t;const n=t.getPosition(),r=WordOperations._moveWordPartRight(e,n);return new Range(n.lineNumber,n.column,r.lineNumber,r.column)}static _createWordAtPosition(e,t,n){const r=new Range(t,n.start+1,t,n.end+1);return{word:e.getValueInRange(r),startColumn:r.startColumn,endColumn:r.endColumn}}static getWordAtPosition(e,t,n){const r=getMapForWordSeparators(t),i=WordOperations._findPreviousWordOnLine(r,e,n);if(i&&1===i.wordType&&i.start<=n.column-1&&n.column-1<=i.end)return WordOperations._createWordAtPosition(e,n.lineNumber,i);const o=WordOperations._findNextWordOnLine(r,e,n);return o&&1===o.wordType&&o.start<=n.column-1&&n.column-1<=o.end?WordOperations._createWordAtPosition(e,n.lineNumber,o):null}static word(e,t,n,r,i){const o=getMapForWordSeparators(e.wordSeparators),s=WordOperations._findPreviousWordOnLine(o,t,i),a=WordOperations._findNextWordOnLine(o,t,i);if(!r){let e,n;return s&&1===s.wordType&&s.start<=i.column-1&&i.column-1<=s.end?(e=s.start+1,n=s.end+1):a&&1===a.wordType&&a.start<=i.column-1&&i.column-1<=a.end?(e=a.start+1,n=a.end+1):(e=s?s.end+1:1,n=a?a.start+1:t.getLineMaxColumn(i.lineNumber)),new SingleCursorState(new Range(i.lineNumber,e,i.lineNumber,n),1,0,new Position(i.lineNumber,n),0)}let d,l;s&&1===s.wordType&&s.start<i.column-1&&i.column-1<s.end?(d=s.start+1,l=s.end+1):a&&1===a.wordType&&a.start<i.column-1&&i.column-1<a.end?(d=a.start+1,l=a.end+1):(d=i.column,l=i.column);const u=i.lineNumber;let c;if(n.selectionStart.containsPosition(i))c=n.selectionStart.endColumn;else if(i.isBeforeOrEqual(n.selectionStart.getStartPosition())){c=d;const e=new Position(u,c);n.selectionStart.containsPosition(e)&&(c=n.selectionStart.endColumn)}else{c=l;const e=new Position(u,c);n.selectionStart.containsPosition(e)&&(c=n.selectionStart.startColumn)}return n.move(!0,u,c,0)}}export class WordPartOperations extends WordOperations{static deleteWordPartLeft(e){const t=enforceDefined([WordOperations.deleteWordLeft(e,0),WordOperations.deleteWordLeft(e,2),WordOperations._deleteWordPartLeft(e.model,e.selection)]);return t.sort(Range.compareRangesUsingEnds),t[2]}static deleteWordPartRight(e){const t=enforceDefined([WordOperations.deleteWordRight(e,0),WordOperations.deleteWordRight(e,2),WordOperations._deleteWordPartRight(e.model,e.selection)]);return t.sort(Range.compareRangesUsingStarts),t[0]}static moveWordPartLeft(e,t,n){const r=enforceDefined([WordOperations.moveWordLeft(e,t,n,0),WordOperations.moveWordLeft(e,t,n,2),WordOperations._moveWordPartLeft(t,n)]);return r.sort(Position.compare),r[2]}static moveWordPartRight(e,t,n){const r=enforceDefined([WordOperations.moveWordRight(e,t,n,0),WordOperations.moveWordRight(e,t,n,2),WordOperations._moveWordPartRight(t,n)]);return r.sort(Position.compare),r[0]}}function enforceDefined(e){return e.filter((e=>Boolean(e)))}