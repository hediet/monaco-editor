import*as strings from"../../../base/common/strings.js";import{getMapForWordSeparators}from"../core/wordCharacterClassifier.js";import{Position}from"../core/position.js";import{Range}from"../core/range.js";import{FindMatch,SearchData}from"../model.js";const LIMIT_FIND_COUNT=999;export class SearchParams{constructor(e,t,n,r){this.searchString=e,this.isRegex=t,this.matchCase=n,this.wordSeparators=r}parseSearchRequest(){if(""===this.searchString)return null;let e;e=this.isRegex?isMultilineRegexSource(this.searchString):this.searchString.indexOf("\n")>=0;let t=null;try{t=strings.createRegExp(this.searchString,this.isRegex,{matchCase:this.matchCase,wholeWord:!1,multiline:e,global:!0,unicode:!0})}catch(e){return null}if(!t)return null;let n=!this.isRegex&&!e;return n&&this.searchString.toLowerCase()!==this.searchString.toUpperCase()&&(n=this.matchCase),new SearchData(t,this.wordSeparators?getMapForWordSeparators(this.wordSeparators):null,n?this.searchString:null)}}export function isMultilineRegexSource(e){if(!e||0===e.length)return!1;for(let t=0,n=e.length;t<n;t++){const r=e.charCodeAt(t);if(10===r)return!0;if(92===r){if(t++,t>=n)break;const r=e.charCodeAt(t);if(110===r||114===r||87===r)return!0}}return!1}export function createFindMatch(e,t,n){if(!n)return new FindMatch(e,null);const r=[];for(let e=0,n=t.length;e<n;e++)r[e]=t[e];return new FindMatch(e,r)}class LineFeedCounter{constructor(e){const t=[];let n=0;for(let r=0,i=e.length;r<i;r++)10===e.charCodeAt(r)&&(t[n++]=r);this._lineFeedsOffsets=t}findLineFeedCountBeforeOffset(e){const t=this._lineFeedsOffsets;let n=0,r=t.length-1;if(-1===r)return 0;if(e<=t[0])return 0;for(;n<r;){const i=n+((r-n)/2>>0);t[i]>=e?r=i-1:t[i+1]>=e?(n=i,r=i):n=i+1}return n+1}}export class TextModelSearch{static findMatches(e,t,n,r,i){const s=t.parseSearchRequest();return s?s.regex.multiline?this._doFindMatchesMultiline(e,n,new Searcher(s.wordSeparators,s.regex),r,i):this._doFindMatchesLineByLine(e,n,s,r,i):[]}static _getMultilineMatchRange(e,t,n,r,i,s){let a,o,c=0;if(r?(c=r.findLineFeedCountBeforeOffset(i),a=t+i+c):a=t+i,r){const e=r.findLineFeedCountBeforeOffset(i+s.length)-c;o=a+s.length+e}else o=a+s.length;const h=e.getPositionAt(a),u=e.getPositionAt(o);return new Range(h.lineNumber,h.column,u.lineNumber,u.column)}static _doFindMatchesMultiline(e,t,n,r,i){const s=e.getOffsetAt(t.getStartPosition()),a=e.getValueInRange(t,1),o="\r\n"===e.getEOL()?new LineFeedCounter(a):null,c=[];let h,u=0;for(n.reset(0);h=n.next(a);)if(c[u++]=createFindMatch(this._getMultilineMatchRange(e,s,a,o,h.index,h[0]),h,r),u>=i)return c;return c}static _doFindMatchesLineByLine(e,t,n,r,i){const s=[];let a=0;if(t.startLineNumber===t.endLineNumber){const o=e.getLineContent(t.startLineNumber).substring(t.startColumn-1,t.endColumn-1);return a=this._findMatchesInLine(n,o,t.startLineNumber,t.startColumn-1,a,s,r,i),s}const o=e.getLineContent(t.startLineNumber).substring(t.startColumn-1);a=this._findMatchesInLine(n,o,t.startLineNumber,t.startColumn-1,a,s,r,i);for(let o=t.startLineNumber+1;o<t.endLineNumber&&a<i;o++)a=this._findMatchesInLine(n,e.getLineContent(o),o,0,a,s,r,i);if(a<i){const o=e.getLineContent(t.endLineNumber).substring(0,t.endColumn-1);a=this._findMatchesInLine(n,o,t.endLineNumber,0,a,s,r,i)}return s}static _findMatchesInLine(e,t,n,r,i,s,a,o){const c=e.wordSeparators;if(!a&&e.simpleSearch){const a=e.simpleSearch,h=a.length,u=t.length;let l=-h;for(;-1!==(l=t.indexOf(a,l+h));)if((!c||isValidMatch(c,t,u,l,h))&&(s[i++]=new FindMatch(new Range(n,l+1+r,n,l+1+h+r),null),i>=o))return i;return i}const h=new Searcher(e.wordSeparators,e.regex);let u;h.reset(0);do{if(u=h.next(t),u&&(s[i++]=createFindMatch(new Range(n,u.index+1+r,n,u.index+1+u[0].length+r),u,a),i>=o))return i}while(u);return i}static findNextMatch(e,t,n,r){const i=t.parseSearchRequest();if(!i)return null;const s=new Searcher(i.wordSeparators,i.regex);return i.regex.multiline?this._doFindNextMatchMultiline(e,n,s,r):this._doFindNextMatchLineByLine(e,n,s,r)}static _doFindNextMatchMultiline(e,t,n,r){const i=new Position(t.lineNumber,1),s=e.getOffsetAt(i),a=e.getLineCount(),o=e.getValueInRange(new Range(i.lineNumber,i.column,a,e.getLineMaxColumn(a)),1),c="\r\n"===e.getEOL()?new LineFeedCounter(o):null;n.reset(t.column-1);const h=n.next(o);return h?createFindMatch(this._getMultilineMatchRange(e,s,o,c,h.index,h[0]),h,r):1!==t.lineNumber||1!==t.column?this._doFindNextMatchMultiline(e,new Position(1,1),n,r):null}static _doFindNextMatchLineByLine(e,t,n,r){const i=e.getLineCount(),s=t.lineNumber,a=e.getLineContent(s),o=this._findFirstMatchInLine(n,a,s,t.column,r);if(o)return o;for(let t=1;t<=i;t++){const a=(s+t-1)%i,o=e.getLineContent(a+1),c=this._findFirstMatchInLine(n,o,a+1,1,r);if(c)return c}return null}static _findFirstMatchInLine(e,t,n,r,i){e.reset(r-1);const s=e.next(t);return s?createFindMatch(new Range(n,s.index+1,n,s.index+1+s[0].length),s,i):null}static findPreviousMatch(e,t,n,r){const i=t.parseSearchRequest();if(!i)return null;const s=new Searcher(i.wordSeparators,i.regex);return i.regex.multiline?this._doFindPreviousMatchMultiline(e,n,s,r):this._doFindPreviousMatchLineByLine(e,n,s,r)}static _doFindPreviousMatchMultiline(e,t,n,r){const i=this._doFindMatchesMultiline(e,new Range(1,1,t.lineNumber,t.column),n,r,9990);if(i.length>0)return i[i.length-1];const s=e.getLineCount();return t.lineNumber!==s||t.column!==e.getLineMaxColumn(s)?this._doFindPreviousMatchMultiline(e,new Position(s,e.getLineMaxColumn(s)),n,r):null}static _doFindPreviousMatchLineByLine(e,t,n,r){const i=e.getLineCount(),s=t.lineNumber,a=e.getLineContent(s).substring(0,t.column-1),o=this._findLastMatchInLine(n,a,s,r);if(o)return o;for(let t=1;t<=i;t++){const a=(i+s-t-1)%i,o=e.getLineContent(a+1),c=this._findLastMatchInLine(n,o,a+1,r);if(c)return c}return null}static _findLastMatchInLine(e,t,n,r){let i,s=null;for(e.reset(0);i=e.next(t);)s=createFindMatch(new Range(n,i.index+1,n,i.index+1+i[0].length),i,r);return s}}function leftIsWordBounday(e,t,n,r,i){if(0===r)return!0;const s=t.charCodeAt(r-1);if(0!==e.get(s))return!0;if(13===s||10===s)return!0;if(i>0){const n=t.charCodeAt(r);if(0!==e.get(n))return!0}return!1}function rightIsWordBounday(e,t,n,r,i){if(r+i===n)return!0;const s=t.charCodeAt(r+i);if(0!==e.get(s))return!0;if(13===s||10===s)return!0;if(i>0){const n=t.charCodeAt(r+i-1);if(0!==e.get(n))return!0}return!1}export function isValidMatch(e,t,n,r,i){return leftIsWordBounday(e,t,n,r,i)&&rightIsWordBounday(e,t,n,r,i)}export class Searcher{constructor(e,t){this._wordSeparators=e,this._searchRegex=t,this._prevMatchStartIndex=-1,this._prevMatchLength=0}reset(e){this._searchRegex.lastIndex=e,this._prevMatchStartIndex=-1,this._prevMatchLength=0}next(e){const t=e.length;let n;do{if(this._prevMatchStartIndex+this._prevMatchLength===t)return null;if(n=this._searchRegex.exec(e),!n)return null;const r=n.index,i=n[0].length;if(r===this._prevMatchStartIndex&&i===this._prevMatchLength){if(0===i){strings.getNextCodePoint(e,t,this._searchRegex.lastIndex)>65535?this._searchRegex.lastIndex+=2:this._searchRegex.lastIndex+=1;continue}return null}if(this._prevMatchStartIndex=r,this._prevMatchLength=i,!this._wordSeparators||isValidMatch(this._wordSeparators,e,t,r,i))return n}while(n);return null}}