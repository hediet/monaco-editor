import{Emitter}from"../../../../base/common/event.js";import*as strings from"../../../../base/common/strings.js";import{Range}from"../../core/range.js";import{ApplyEditsResult}from"../../model.js";import{PieceTreeBase}from"./pieceTreeBase.js";import{countEOL}from"../../core/eolCounter.js";import{TextChange}from"../../core/textChange.js";import{Disposable}from"../../../../base/common/lifecycle.js";export class PieceTreeTextBuffer extends Disposable{constructor(e,t,n,r,i,s,o){super(),this._onDidChangeContent=this._register(new Emitter),this._BOM=t,this._mightContainNonBasicASCII=!s,this._mightContainRTL=r,this._mightContainUnusualLineTerminators=i,this._pieceTree=new PieceTreeBase(e,n,o)}mightContainRTL(){return this._mightContainRTL}mightContainUnusualLineTerminators(){return this._mightContainUnusualLineTerminators}resetMightContainUnusualLineTerminators(){this._mightContainUnusualLineTerminators=!1}mightContainNonBasicASCII(){return this._mightContainNonBasicASCII}getBOM(){return this._BOM}getEOL(){return this._pieceTree.getEOL()}createSnapshot(e){return this._pieceTree.createSnapshot(e?this._BOM:"")}getOffsetAt(e,t){return this._pieceTree.getOffsetAt(e,t)}getPositionAt(e){return this._pieceTree.getPositionAt(e)}getRangeAt(e,t){const n=e+t,r=this.getPositionAt(e),i=this.getPositionAt(n);return new Range(r.lineNumber,r.column,i.lineNumber,i.column)}getValueInRange(e,t=0){if(e.isEmpty())return"";const n=this._getEndOfLine(t);return this._pieceTree.getValueInRange(e,n)}getValueLengthInRange(e,t=0){if(e.isEmpty())return 0;if(e.startLineNumber===e.endLineNumber)return e.endColumn-e.startColumn;const n=this.getOffsetAt(e.startLineNumber,e.startColumn),r=this.getOffsetAt(e.endLineNumber,e.endColumn);let i=0;const s=this._getEndOfLine(t),o=this.getEOL();return s.length!==o.length&&(i=(s.length-o.length)*(e.endLineNumber-e.startLineNumber)),r-n+i}getCharacterCountInRange(e,t=0){if(this._mightContainNonBasicASCII){let n=0;const r=e.startLineNumber,i=e.endLineNumber;for(let t=r;t<=i;t++){const s=this.getLineContent(t),o=t===r?e.startColumn-1:0,a=t===i?e.endColumn-1:s.length;for(let e=o;e<a;e++)strings.isHighSurrogate(s.charCodeAt(e))?(n+=1,e+=1):n+=1}return n+=this._getEndOfLine(t).length*(i-r),n}return this.getValueLengthInRange(e,t)}getLength(){return this._pieceTree.getLength()}getLineCount(){return this._pieceTree.getLineCount()}getLinesContent(){return this._pieceTree.getLinesContent()}getLineContent(e){return this._pieceTree.getLineContent(e)}getLineCharCode(e,t){return this._pieceTree.getLineCharCode(e,t)}getLineLength(e){return this._pieceTree.getLineLength(e)}getLineFirstNonWhitespaceColumn(e){const t=strings.firstNonWhitespaceIndex(this.getLineContent(e));return-1===t?0:t+1}getLineLastNonWhitespaceColumn(e){const t=strings.lastNonWhitespaceIndex(this.getLineContent(e));return-1===t?0:t+2}_getEndOfLine(e){switch(e){case 1:return"\n";case 2:return"\r\n";case 0:return this.getEOL();default:throw new Error("Unknown EOL preference")}}setEOL(e){this._pieceTree.setEOL(e)}applyEdits(e,t,n){let r=this._mightContainRTL,i=this._mightContainUnusualLineTerminators,s=this._mightContainNonBasicASCII,o=!0,a=[];for(let t=0;t<e.length;t++){const n=e[t];o&&n._isTracked&&(o=!1);const g=n.range;if(n.text){let e=!0;s||(e=!strings.isBasicASCII(n.text),s=e),!r&&e&&(r=strings.containsRTL(n.text)),!i&&e&&(i=strings.containsUnusualLineTerminators(n.text))}let h="",u=0,l=0,c=0;if(n.text){let e;[u,l,c,e]=countEOL(n.text);const t=this.getEOL(),r="\r\n"===t?2:1;h=0===e||e===r?n.text:n.text.replace(/\r\n|\r|\n/g,t)}a[t]={sortIndex:t,identifier:n.identifier||null,range:g,rangeOffset:this.getOffsetAt(g.startLineNumber,g.startColumn),rangeLength:this.getValueLengthInRange(g),text:h,eolCount:u,firstLineLength:l,lastLineLength:c,forceMoveMarkers:Boolean(n.forceMoveMarkers),isAutoWhitespaceEdit:n.isAutoWhitespaceEdit||!1}}a.sort(PieceTreeTextBuffer._sortOpsAscending);let g=!1;for(let e=0,t=a.length-1;e<t;e++){const t=a[e].range.getEndPosition(),n=a[e+1].range.getStartPosition();if(n.isBeforeOrEqual(t)){if(n.isBefore(t))throw new Error("Overlapping ranges are not allowed!");g=!0}}o&&(a=this._reduceOperations(a));const h=n||t?PieceTreeTextBuffer._getInverseEditRanges(a):[],u=[];if(t)for(let e=0;e<a.length;e++){const t=a[e],n=h[e];if(t.isAutoWhitespaceEdit&&t.range.isEmpty())for(let e=n.startLineNumber;e<=n.endLineNumber;e++){let r="";e===n.startLineNumber&&(r=this.getLineContent(t.range.startLineNumber),-1!==strings.firstNonWhitespaceIndex(r))||u.push({lineNumber:e,oldContent:r})}}let l=null;if(n){let e=0;l=[];for(let t=0;t<a.length;t++){const n=a[t],r=h[t],i=this.getValueInRange(n.range),s=n.rangeOffset+e;e+=n.text.length-i.length,l[t]={sortIndex:n.sortIndex,identifier:n.identifier,range:r,text:i,textChange:new TextChange(n.rangeOffset,i,s,n.text)}}g||l.sort(((e,t)=>e.sortIndex-t.sortIndex))}this._mightContainRTL=r,this._mightContainUnusualLineTerminators=i,this._mightContainNonBasicASCII=s;const c=this._doApplyEdits(a);let m=null;if(t&&u.length>0){u.sort(((e,t)=>t.lineNumber-e.lineNumber)),m=[];for(let e=0,t=u.length;e<t;e++){const t=u[e].lineNumber;if(e>0&&u[e-1].lineNumber===t)continue;const n=u[e].oldContent,r=this.getLineContent(t);0!==r.length&&r!==n&&-1===strings.firstNonWhitespaceIndex(r)&&m.push(t)}}return this._onDidChangeContent.fire(),new ApplyEditsResult(l,c,m)}_reduceOperations(e){return e.length<1e3?e:[this._toSingleEditOperation(e)]}_toSingleEditOperation(e){let t=!1;const n=e[0].range,r=e[e.length-1].range,i=new Range(n.startLineNumber,n.startColumn,r.endLineNumber,r.endColumn);let s=n.startLineNumber,o=n.startColumn;const a=[];for(let n=0,r=e.length;n<r;n++){const r=e[n],i=r.range;t=t||r.forceMoveMarkers,a.push(this.getValueInRange(new Range(s,o,i.startLineNumber,i.startColumn))),r.text.length>0&&a.push(r.text),s=i.endLineNumber,o=i.endColumn}const g=a.join(""),[h,u,l]=countEOL(g);return{sortIndex:0,identifier:e[0].identifier,range:i,rangeOffset:this.getOffsetAt(i.startLineNumber,i.startColumn),rangeLength:this.getValueLengthInRange(i,0),text:g,eolCount:h,firstLineLength:u,lastLineLength:l,forceMoveMarkers:t,isAutoWhitespaceEdit:!1}}_doApplyEdits(e){e.sort(PieceTreeTextBuffer._sortOpsDescending);const t=[];for(let n=0;n<e.length;n++){const r=e[n],i=r.range.startLineNumber,s=r.range.startColumn,o=r.range.endLineNumber,a=r.range.endColumn;if(i===o&&s===a&&0===r.text.length)continue;r.text?(this._pieceTree.delete(r.rangeOffset,r.rangeLength),this._pieceTree.insert(r.rangeOffset,r.text,!0)):this._pieceTree.delete(r.rangeOffset,r.rangeLength);const g=new Range(i,s,o,a);t.push({range:g,rangeLength:r.rangeLength,text:r.text,rangeOffset:r.rangeOffset,forceMoveMarkers:r.forceMoveMarkers})}return t}findMatchesLineByLine(e,t,n,r){return this._pieceTree.findMatchesLineByLine(e,t,n,r)}static _getInverseEditRanges(e){const t=[];let n=0,r=0,i=null;for(let s=0,o=e.length;s<o;s++){const o=e[s];let a,g,h;if(i?i.range.endLineNumber===o.range.startLineNumber?(a=n,g=r+(o.range.startColumn-i.range.endColumn)):(a=n+(o.range.startLineNumber-i.range.endLineNumber),g=o.range.startColumn):(a=o.range.startLineNumber,g=o.range.startColumn),o.text.length>0){const e=o.eolCount+1;h=1===e?new Range(a,g,a,g+o.firstLineLength):new Range(a,g,a+e-1,o.lastLineLength+1)}else h=new Range(a,g,a,g);n=h.endLineNumber,r=h.endColumn,t.push(h),i=o}return t}static _sortOpsAscending(e,t){const n=Range.compareRangesUsingEnds(e.range,t.range);return 0===n?e.sortIndex-t.sortIndex:n}static _sortOpsDescending(e,t){const n=Range.compareRangesUsingEnds(e.range,t.range);return 0===n?t.sortIndex-e.sortIndex:-n}}