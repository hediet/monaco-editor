import{NotSupportedError}from"../../../../../base/common/errors.js";import{TokenMetadata}from"../../../encodedTokenAttributes.js";import{TextAstNode}from"./ast.js";import{lengthAdd,lengthDiff,lengthGetColumnCountIfZeroLineCount,lengthToObj,lengthZero,toLength}from"./length.js";import{SmallImmutableSet}from"./smallImmutableSet.js";export class Token{constructor(e,t,n,s,i){this.length=e,this.kind=t,this.bracketId=n,this.bracketIds=s,this.astNode=i}}export class TextBufferTokenizer{constructor(e,t){this.textModel=e,this.bracketTokens=t,this.reader=new NonPeekableTextBufferTokenizer(this.textModel,this.bracketTokens),this._offset=lengthZero,this.didPeek=!1,this.peeked=null,this.textBufferLineCount=e.getLineCount(),this.textBufferLastLineLength=e.getLineLength(this.textBufferLineCount)}get offset(){return this._offset}get length(){return toLength(this.textBufferLineCount-1,this.textBufferLastLineLength)}skip(e){this.didPeek=!1,this._offset=lengthAdd(this._offset,e);const t=lengthToObj(this._offset);this.reader.setPosition(t.lineCount,t.columnCount)}read(){let e;return this.peeked?(this.didPeek=!1,e=this.peeked):e=this.reader.read(),e&&(this._offset=lengthAdd(this._offset,e.length)),e}peek(){return this.didPeek||(this.peeked=this.reader.read(),this.didPeek=!0),this.peeked}}class NonPeekableTextBufferTokenizer{constructor(e,t){this.textModel=e,this.bracketTokens=t,this.lineIdx=0,this.line=null,this.lineCharOffset=0,this.lineTokens=null,this.lineTokenOffset=0,this.peekedToken=null,this.textBufferLineCount=e.getLineCount(),this.textBufferLastLineLength=e.getLineLength(this.textBufferLineCount)}setPosition(e,t){e===this.lineIdx?(this.lineCharOffset=t,null!==this.line&&(this.lineTokenOffset=0===this.lineCharOffset?0:this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset))):(this.lineIdx=e,this.lineCharOffset=t,this.line=null),this.peekedToken=null}read(){if(this.peekedToken){const e=this.peekedToken;return this.peekedToken=null,this.lineCharOffset+=lengthGetColumnCountIfZeroLineCount(e.length),e}if(this.lineIdx>this.textBufferLineCount-1||this.lineIdx===this.textBufferLineCount-1&&this.lineCharOffset>=this.textBufferLastLineLength)return null;null===this.line&&(this.lineTokens=this.textModel.tokenization.getLineTokens(this.lineIdx+1),this.line=this.lineTokens.getLineContent(),this.lineTokenOffset=0===this.lineCharOffset?0:this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset));const e=this.lineIdx,t=this.lineCharOffset;let n=0;for(;;){const s=this.lineTokens,i=s.getCount();let o=null;if(this.lineTokenOffset<i){const h=s.getMetadata(this.lineTokenOffset);for(;this.lineTokenOffset+1<i&&h===s.getMetadata(this.lineTokenOffset+1);)this.lineTokenOffset++;const l=0===TokenMetadata.getTokenType(h),f=TokenMetadata.containsBalancedBrackets(h),r=s.getEndOffset(this.lineTokenOffset);if(f&&l&&this.lineCharOffset<r){const e=s.getLanguageId(this.lineTokenOffset),t=this.line.substring(this.lineCharOffset,r),n=this.bracketTokens.getSingleLanguageBracketTokens(e),i=n.regExpGlobal;if(i){i.lastIndex=0;const e=i.exec(t);e&&(o=n.getToken(e[0]),o&&(this.lineCharOffset+=e.index))}}if(n+=r-this.lineCharOffset,o){if(e!==this.lineIdx||t!==this.lineCharOffset){this.peekedToken=o;break}return this.lineCharOffset+=lengthGetColumnCountIfZeroLineCount(o.length),o}this.lineTokenOffset++,this.lineCharOffset=r}else{if(this.lineIdx===this.textBufferLineCount-1)break;if(this.lineIdx++,this.lineTokens=this.textModel.tokenization.getLineTokens(this.lineIdx+1),this.lineTokenOffset=0,this.line=this.lineTokens.getLineContent(),this.lineCharOffset=0,n+=33,n>1e3)break}if(n>1500)break}const s=lengthDiff(e,t,this.lineIdx,this.lineCharOffset);return new Token(s,0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(s))}}export class FastTokenizer{constructor(e,t){this.text=e,this._offset=lengthZero,this.idx=0;const n=t.getRegExpStr(),s=n?new RegExp(n+"|\n","gi"):null,i=[];let o,h=0,l=0,f=0,r=0;const a=[];for(let e=0;e<60;e++)a.push(new Token(toLength(0,e),0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(toLength(0,e))));const k=[];for(let e=0;e<60;e++)k.push(new Token(toLength(1,e),0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(toLength(1,e))));if(s)for(s.lastIndex=0;null!==(o=s.exec(e));){const e=o.index,n=o[0];if("\n"===n)h++,l=e+1;else{if(f!==e){let t;if(r===h){const n=e-f;if(n<a.length)t=a[n];else{const e=toLength(0,n);t=new Token(e,0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(e))}}else{const n=h-r,s=e-l;if(1===n&&s<k.length)t=k[s];else{const e=toLength(n,s);t=new Token(e,0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(e))}}i.push(t)}i.push(t.getToken(n)),f=e+n.length,r=h}}const d=e.length;if(f!==d){const e=r===h?toLength(0,d-f):toLength(h-r,d-l);i.push(new Token(e,0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(e)))}this.length=toLength(h,d-l),this.tokens=i}get offset(){return this._offset}read(){return this.tokens[this.idx++]||null}peek(){return this.tokens[this.idx]||null}skip(e){throw new NotSupportedError}}