const emptyArr=[];class SmallImmutableSet{static create(t,e){if(t<=128&&0===e.length){let i=SmallImmutableSet.cache[t];return i||(i=new SmallImmutableSet(t,e),SmallImmutableSet.cache[t]=i),i}return new SmallImmutableSet(t,e)}static getEmpty(){return this.empty}constructor(t,e){this.items=t,this.additionalItems=e}add(t,e){const i=e.getKey(t);let m=i>>5;if(0===m){const t=1<<i|this.items;return t===this.items?this:SmallImmutableSet.create(t,this.additionalItems)}m--;const s=this.additionalItems.slice(0);for(;s.length<m;)s.push(0);return s[m]|=1<<(31&i),SmallImmutableSet.create(this.items,s)}merge(t){const e=this.items|t.items;if(this.additionalItems===emptyArr&&t.additionalItems===emptyArr)return e===this.items?this:e===t.items?t:SmallImmutableSet.create(e,emptyArr);const i=[];for(let e=0;e<Math.max(this.additionalItems.length,t.additionalItems.length);e++){const m=this.additionalItems[e]||0,s=t.additionalItems[e]||0;i.push(m|s)}return SmallImmutableSet.create(e,i)}intersects(t){if(0!=(this.items&t.items))return!0;for(let e=0;e<Math.min(this.additionalItems.length,t.additionalItems.length);e++)if(0!=(this.additionalItems[e]&t.additionalItems[e]))return!0;return!1}}SmallImmutableSet.cache=new Array(129),SmallImmutableSet.empty=SmallImmutableSet.create(0,emptyArr);export{SmallImmutableSet};export const identityKeyProvider={getKey:t=>t};export class DenseKeyProvider{constructor(){this.items=new Map}getKey(t){let e=this.items.get(t);return void 0===e&&(e=this.items.size,this.items.set(t,e)),e}}