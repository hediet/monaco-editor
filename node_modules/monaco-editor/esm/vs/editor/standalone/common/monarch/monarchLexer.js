var __decorate=this&&this.__decorate||function(e,t,n,a){var r,o=arguments.length,s=o<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,a);else for(var i=e.length-1;i>=0;i--)(r=e[i])&&(s=(o<3?r(s):o>3?r(t,n,s):r(t,n))||s);return o>3&&s&&Object.defineProperty(t,n,s),s},__param=this&&this.__param||function(e,t){return function(n,a){t(n,a,e)}};import*as languages from"../../../common/languages.js";import{NullState,nullTokenizeEncoded,nullTokenize}from"../../../common/languages/nullTokenize.js";import*as monarchCommon from"./monarchCommon.js";import{IConfigurationService}from"../../../../platform/configuration/common/configuration.js";const CACHE_STACK_DEPTH=5;class MonarchStackElementFactory{static create(e,t){return this._INSTANCE.create(e,t)}constructor(e){this._maxCacheDepth=e,this._entries=Object.create(null)}create(e,t){if(null!==e&&e.depth>=this._maxCacheDepth)return new MonarchStackElement(e,t);let n=MonarchStackElement.getStackElementId(e);n.length>0&&(n+="|"),n+=t;let a=this._entries[n];return a||(a=new MonarchStackElement(e,t),this._entries[n]=a,a)}}MonarchStackElementFactory._INSTANCE=new MonarchStackElementFactory(5);class MonarchStackElement{constructor(e,t){this.parent=e,this.state=t,this.depth=(this.parent?this.parent.depth:0)+1}static getStackElementId(e){let t="";for(;null!==e;)t.length>0&&(t+="|"),t+=e.state,e=e.parent;return t}static _equals(e,t){for(;null!==e&&null!==t;){if(e===t)return!0;if(e.state!==t.state)return!1;e=e.parent,t=t.parent}return null===e&&null===t}equals(e){return MonarchStackElement._equals(this,e)}push(e){return MonarchStackElementFactory.create(this,e)}pop(){return this.parent}popall(){let e=this;for(;e.parent;)e=e.parent;return e}switchTo(e){return MonarchStackElementFactory.create(this.parent,e)}}class EmbeddedLanguageData{constructor(e,t){this.languageId=e,this.state=t}equals(e){return this.languageId===e.languageId&&this.state.equals(e.state)}clone(){return this.state.clone()===this.state?this:new EmbeddedLanguageData(this.languageId,this.state)}}class MonarchLineStateFactory{static create(e,t){return this._INSTANCE.create(e,t)}constructor(e){this._maxCacheDepth=e,this._entries=Object.create(null)}create(e,t){if(null!==t)return new MonarchLineState(e,t);if(null!==e&&e.depth>=this._maxCacheDepth)return new MonarchLineState(e,t);const n=MonarchStackElement.getStackElementId(e);let a=this._entries[n];return a||(a=new MonarchLineState(e,null),this._entries[n]=a,a)}}MonarchLineStateFactory._INSTANCE=new MonarchLineStateFactory(5);class MonarchLineState{constructor(e,t){this.stack=e,this.embeddedLanguageData=t}clone(){return(this.embeddedLanguageData?this.embeddedLanguageData.clone():null)===this.embeddedLanguageData?this:MonarchLineStateFactory.create(this.stack,this.embeddedLanguageData)}equals(e){return e instanceof MonarchLineState&&!!this.stack.equals(e.stack)&&(null===this.embeddedLanguageData&&null===e.embeddedLanguageData||null!==this.embeddedLanguageData&&null!==e.embeddedLanguageData&&this.embeddedLanguageData.equals(e.embeddedLanguageData))}}class MonarchClassicTokensCollector{constructor(){this._tokens=[],this._languageId=null,this._lastTokenType=null,this._lastTokenLanguage=null}enterLanguage(e){this._languageId=e}emit(e,t){this._lastTokenType===t&&this._lastTokenLanguage===this._languageId||(this._lastTokenType=t,this._lastTokenLanguage=this._languageId,this._tokens.push(new languages.Token(e,t,this._languageId)))}nestedLanguageTokenize(e,t,n,a){const r=n.languageId,o=n.state,s=languages.TokenizationRegistry.get(r);if(!s)return this.enterLanguage(r),this.emit(a,""),o;const i=s.tokenize(e,t,o);if(0!==a)for(const e of i.tokens)this._tokens.push(new languages.Token(e.offset+a,e.type,e.language));else this._tokens=this._tokens.concat(i.tokens);return this._lastTokenType=null,this._lastTokenLanguage=null,this._languageId=null,i.endState}finalize(e){return new languages.TokenizationResult(this._tokens,e)}}class MonarchModernTokensCollector{constructor(e,t){this._languageService=e,this._theme=t,this._prependTokens=null,this._tokens=[],this._currentLanguageId=0,this._lastTokenMetadata=0}enterLanguage(e){this._currentLanguageId=this._languageService.languageIdCodec.encodeLanguageId(e)}emit(e,t){const n=1024|this._theme.match(this._currentLanguageId,t);this._lastTokenMetadata!==n&&(this._lastTokenMetadata=n,this._tokens.push(e),this._tokens.push(n))}static _merge(e,t,n){const a=null!==e?e.length:0,r=t.length,o=null!==n?n.length:0;if(0===a&&0===r&&0===o)return new Uint32Array(0);if(0===a&&0===r)return n;if(0===r&&0===o)return e;const s=new Uint32Array(a+r+o);null!==e&&s.set(e);for(let e=0;e<r;e++)s[a+e]=t[e];return null!==n&&s.set(n,a+r),s}nestedLanguageTokenize(e,t,n,a){const r=n.languageId,o=n.state,s=languages.TokenizationRegistry.get(r);if(!s)return this.enterLanguage(r),this.emit(a,""),o;const i=s.tokenizeEncoded(e,t,o);if(0!==a)for(let e=0,t=i.tokens.length;e<t;e+=2)i.tokens[e]+=a;return this._prependTokens=MonarchModernTokensCollector._merge(this._prependTokens,this._tokens,i.tokens),this._tokens=[],this._currentLanguageId=0,this._lastTokenMetadata=0,i.endState}finalize(e){return new languages.EncodedTokenizationResult(MonarchModernTokensCollector._merge(this._prependTokens,this._tokens,null),e)}}let MonarchTokenizer=class e{constructor(e,t,n,a,r){this._configurationService=r,this._languageService=e,this._standaloneThemeService=t,this._languageId=n,this._lexer=a,this._embeddedLanguages=Object.create(null),this.embeddedLoaded=Promise.resolve(void 0);let o=!1;this._tokenizationRegistryListener=languages.TokenizationRegistry.onDidChange((e=>{if(o)return;let t=!1;for(let n=0,a=e.changedLanguages.length;n<a;n++){const a=e.changedLanguages[n];if(this._embeddedLanguages[a]){t=!0;break}}t&&(o=!0,languages.TokenizationRegistry.fire([this._languageId]),o=!1)})),this._maxTokenizationLineLength=this._configurationService.getValue("editor.maxTokenizationLineLength",{overrideIdentifier:this._languageId}),this._configurationService.onDidChangeConfiguration((e=>{e.affectsConfiguration("editor.maxTokenizationLineLength")&&(this._maxTokenizationLineLength=this._configurationService.getValue("editor.maxTokenizationLineLength",{overrideIdentifier:this._languageId}))}))}dispose(){this._tokenizationRegistryListener.dispose()}getLoadStatus(){const t=[];for(const n in this._embeddedLanguages){const a=languages.TokenizationRegistry.get(n);if(a){if(a instanceof e){const e=a.getLoadStatus();!1===e.loaded&&t.push(e.promise)}}else languages.TokenizationRegistry.isResolved(n)||t.push(languages.TokenizationRegistry.getOrCreate(n))}return 0===t.length?{loaded:!0}:{loaded:!1,promise:Promise.all(t).then((e=>{}))}}getInitialState(){const e=MonarchStackElementFactory.create(null,this._lexer.start);return MonarchLineStateFactory.create(e,null)}tokenize(e,t,n){if(e.length>=this._maxTokenizationLineLength)return nullTokenize(this._languageId,n);const a=new MonarchClassicTokensCollector,r=this._tokenize(e,t,n,a);return a.finalize(r)}tokenizeEncoded(e,t,n){if(e.length>=this._maxTokenizationLineLength)return nullTokenizeEncoded(this._languageService.languageIdCodec.encodeLanguageId(this._languageId),n);const a=new MonarchModernTokensCollector(this._languageService,this._standaloneThemeService.getColorTheme().tokenTheme),r=this._tokenize(e,t,n,a);return a.finalize(r)}_tokenize(e,t,n,a){return n.embeddedLanguageData?this._nestedTokenize(e,t,n,0,a):this._myTokenize(e,t,n,0,a)}_findLeavingNestedLanguageOffset(e,t){let n=this._lexer.tokenizer[t.stack.state];if(!n&&(n=monarchCommon.findRules(this._lexer,t.stack.state),!n))throw monarchCommon.createError(this._lexer,"tokenizer state is not defined: "+t.stack.state);let a=-1,r=!1;for(const t of n){if(!monarchCommon.isIAction(t.action)||"@pop"!==t.action.nextEmbedded)continue;r=!0;let n=t.regex;const o=t.regex.source;if("^(?:"===o.substr(0,4)&&")"===o.substr(o.length-1,1)){const e=(n.ignoreCase?"i":"")+(n.unicode?"u":"");n=new RegExp(o.substr(4,o.length-5),e)}const s=e.search(n);-1===s||0!==s&&t.matchOnlyAtLineStart||(-1===a||s<a)&&(a=s)}if(!r)throw monarchCommon.createError(this._lexer,'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: '+t.stack.state);return a}_nestedTokenize(e,t,n,a,r){const o=this._findLeavingNestedLanguageOffset(e,n);if(-1===o){const o=r.nestedLanguageTokenize(e,t,n.embeddedLanguageData,a);return MonarchLineStateFactory.create(n.stack,new EmbeddedLanguageData(n.embeddedLanguageData.languageId,o))}const s=e.substring(0,o);s.length>0&&r.nestedLanguageTokenize(s,!1,n.embeddedLanguageData,a);const i=e.substring(o);return this._myTokenize(i,t,n,a+o,r)}_safeRuleName(e){return e?e.name:"(unknown)"}_myTokenize(e,t,n,a,r){r.enterLanguage(this._languageId);const o=e.length,s=t&&this._lexer.includeLF?e+"\n":e,i=s.length;let l=n.embeddedLanguageData,h=n.stack,c=0,u=null,g=!0;for(;g||c<i;){const n=c,d=h.depth,m=u?u.groups.length:0,f=h.state;let _=null,k=null,p=null,L=null,T=null;if(u){_=u.matches;const e=u.groups.shift();k=e.matched,p=e.action,L=u.rule,0===u.groups.length&&(u=null)}else{if(!g&&c>=i)break;g=!1;let e=this._lexer.tokenizer[f];if(!e&&(e=monarchCommon.findRules(this._lexer,f),!e))throw monarchCommon.createError(this._lexer,"tokenizer state is not defined: "+f);const t=s.substr(c);for(const n of e)if((0===c||!n.matchOnlyAtLineStart)&&(_=t.match(n.regex),_)){k=_[0],p=n.action;break}}if(_||(_=[""],k=""),p||(c<i&&(_=[s.charAt(c)],k=_[0]),p=this._lexer.defaultToken),null===k)break;for(c+=k.length;monarchCommon.isFuzzyAction(p)&&monarchCommon.isIAction(p)&&p.test;)p=p.test(k,_,f,c===i);let b=null;if("string"==typeof p||Array.isArray(p))b=p;else if(p.group)b=p.group;else if(null!==p.token&&void 0!==p.token){if(b=p.tokenSubst?monarchCommon.substituteMatches(this._lexer,p.token,k,_,f):p.token,p.nextEmbedded)if("@pop"===p.nextEmbedded){if(!l)throw monarchCommon.createError(this._lexer,"cannot pop embedded language if not inside one");l=null}else{if(l)throw monarchCommon.createError(this._lexer,"cannot enter embedded language from within an embedded language");T=monarchCommon.substituteMatches(this._lexer,p.nextEmbedded,k,_,f)}if(p.goBack&&(c=Math.max(0,c-p.goBack)),p.switchTo&&"string"==typeof p.switchTo){let e=monarchCommon.substituteMatches(this._lexer,p.switchTo,k,_,f);if("@"===e[0]&&(e=e.substr(1)),!monarchCommon.findRules(this._lexer,e))throw monarchCommon.createError(this._lexer,"trying to switch to a state '"+e+"' that is undefined in rule: "+this._safeRuleName(L));h=h.switchTo(e)}else{if(p.transform&&"function"==typeof p.transform)throw monarchCommon.createError(this._lexer,"action.transform not supported");if(p.next)if("@push"===p.next){if(h.depth>=this._lexer.maxStack)throw monarchCommon.createError(this._lexer,"maximum tokenizer stack size reached: ["+h.state+","+h.parent.state+",...]");h=h.push(f)}else if("@pop"===p.next){if(h.depth<=1)throw monarchCommon.createError(this._lexer,"trying to pop an empty stack in rule: "+this._safeRuleName(L));h=h.pop()}else if("@popall"===p.next)h=h.popall();else{let e=monarchCommon.substituteMatches(this._lexer,p.next,k,_,f);if("@"===e[0]&&(e=e.substr(1)),!monarchCommon.findRules(this._lexer,e))throw monarchCommon.createError(this._lexer,"trying to set a next state '"+e+"' that is undefined in rule: "+this._safeRuleName(L));h=h.push(e)}}p.log&&"string"==typeof p.log&&monarchCommon.log(this._lexer,this._lexer.languageId+": "+monarchCommon.substituteMatches(this._lexer,p.log,k,_,f))}if(null===b)throw monarchCommon.createError(this._lexer,"lexer rule has no well-defined action in rule: "+this._safeRuleName(L));const x=n=>{const o=this._languageService.getLanguageIdByLanguageName(n)||this._languageService.getLanguageIdByMimeType(n)||n,s=this._getNestedEmbeddedLanguageData(o);if(c<i){const n=e.substr(c);return this._nestedTokenize(n,t,MonarchLineStateFactory.create(h,s),a+c,r)}return MonarchLineStateFactory.create(h,s)};if(Array.isArray(b)){if(u&&u.groups.length>0)throw monarchCommon.createError(this._lexer,"groups cannot be nested: "+this._safeRuleName(L));if(_.length!==b.length+1)throw monarchCommon.createError(this._lexer,"matched number of groups does not match the number of actions in rule: "+this._safeRuleName(L));let e=0;for(let t=1;t<_.length;t++)e+=_[t].length;if(e!==k.length)throw monarchCommon.createError(this._lexer,"with groups, all characters should be matched in consecutive groups in rule: "+this._safeRuleName(L));u={rule:L,matches:_,groups:[]};for(let e=0;e<b.length;e++)u.groups[e]={action:b[e],matched:_[e+1]};c-=k.length}else{{if("@rematch"===b&&(c-=k.length,k="",_=null,b="",null!==T))return x(T);if(0===k.length){if(0===i||d!==h.depth||f!==h.state||(u?u.groups.length:0)!==m)continue;throw monarchCommon.createError(this._lexer,"no progress in tokenizer in rule: "+this._safeRuleName(L))}let e=null;if(monarchCommon.isString(b)&&0===b.indexOf("@brackets")){const t=b.substr("@brackets".length),n=findBracket(this._lexer,k);if(!n)throw monarchCommon.createError(this._lexer,"@brackets token returned but no bracket defined as: "+k);e=monarchCommon.sanitize(n.token+t)}else{const t=""===b?"":b+this._lexer.tokenPostfix;e=monarchCommon.sanitize(t)}n<o&&r.emit(n+a,e)}if(null!==T)return x(T)}}return MonarchLineStateFactory.create(h,l)}_getNestedEmbeddedLanguageData(e){if(!this._languageService.isRegisteredLanguageId(e))return new EmbeddedLanguageData(e,NullState);e!==this._languageId&&(languages.TokenizationRegistry.getOrCreate(e),this._embeddedLanguages[e]=!0);const t=languages.TokenizationRegistry.get(e);return new EmbeddedLanguageData(e,t?t.getInitialState():NullState)}};MonarchTokenizer=__decorate([__param(4,IConfigurationService)],MonarchTokenizer);export{MonarchTokenizer};function findBracket(e,t){if(!t)return null;t=monarchCommon.fixCase(e,t);const n=e.brackets;for(const e of n){if(e.open===t)return{token:e.token,bracketType:1};if(e.close===t)return{token:e.token,bracketType:-1}}return null}