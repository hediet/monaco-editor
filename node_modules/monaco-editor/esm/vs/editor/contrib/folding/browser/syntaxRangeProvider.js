import{onUnexpectedExternalError}from"../../../../base/common/errors.js";import{DisposableStore}from"../../../../base/common/lifecycle.js";import{FoldingRegions,MAX_LINE_NUMBER}from"./foldingRanges.js";const foldingContext={},ID_SYNTAX_PROVIDER="syntax";export class SyntaxRangeProvider{constructor(t,e,n,s,i){this.editorModel=t,this.providers=e,this.handleFoldingRangesChange=n,this.foldingRangesLimit=s,this.fallbackRangeProvider=i,this.id="syntax",this.disposables=new DisposableStore,i&&this.disposables.add(i);for(const t of e)"function"==typeof t.onDidChange&&this.disposables.add(t.onDidChange(n))}compute(t){return collectSyntaxRanges(this.providers,this.editorModel,t).then((e=>{var n,s;return e?sanitizeRanges(e,this.foldingRangesLimit):null!==(s=null===(n=this.fallbackRangeProvider)||void 0===n?void 0:n.compute(t))&&void 0!==s?s:null}))}dispose(){this.disposables.dispose()}}function collectSyntaxRanges(t,e,n){let s=null;const i=t.map(((t,i)=>Promise.resolve(t.provideFoldingRanges(e,foldingContext,n)).then((t=>{if(!n.isCancellationRequested&&Array.isArray(t)){Array.isArray(s)||(s=[]);const n=e.getLineCount();for(const e of t)e.start>0&&e.end>e.start&&e.end<=n&&s.push({start:e.start,end:e.end,rank:i,kind:e.kind})}}),onUnexpectedExternalError)));return Promise.all(i).then((t=>s))}class RangesCollector{constructor(t){this._startIndexes=[],this._endIndexes=[],this._nestingLevels=[],this._nestingLevelCounts=[],this._types=[],this._length=0,this._foldingRangesLimit=t}add(t,e,n,s){if(t>MAX_LINE_NUMBER||e>MAX_LINE_NUMBER)return;const i=this._length;this._startIndexes[i]=t,this._endIndexes[i]=e,this._nestingLevels[i]=s,this._types[i]=n,this._length++,s<30&&(this._nestingLevelCounts[s]=(this._nestingLevelCounts[s]||0)+1)}toIndentRanges(){const t=this._foldingRangesLimit.limit;if(this._length<=t){this._foldingRangesLimit.report({limited:!1,computed:this._length});const t=new Uint32Array(this._length),e=new Uint32Array(this._length);for(let n=0;n<this._length;n++)t[n]=this._startIndexes[n],e[n]=this._endIndexes[n];return new FoldingRegions(t,e,this._types)}{this._foldingRangesLimit.report({limited:t,computed:this._length});let e=0,n=this._nestingLevelCounts.length;for(let s=0;s<this._nestingLevelCounts.length;s++){const i=this._nestingLevelCounts[s];if(i){if(i+e>t){n=s;break}e+=i}}const s=new Uint32Array(t),i=new Uint32Array(t),o=[];for(let r=0,l=0;r<this._length;r++){const a=this._nestingLevels[r];(a<n||a===n&&e++<t)&&(s[l]=this._startIndexes[r],i[l]=this._endIndexes[r],o[l]=this._types[r],l++)}return new FoldingRegions(s,i,o)}}}export function sanitizeRanges(t,e){const n=t.sort(((t,e)=>{let n=t.start-e.start;return 0===n&&(n=t.rank-e.rank),n})),s=new RangesCollector(e);let i;const o=[];for(const t of n)if(i){if(t.start>i.start)if(t.end<=i.end)o.push(i),i=t,s.add(t.start,t.end,t.kind&&t.kind.value,o.length);else{if(t.start>i.end){do{i=o.pop()}while(i&&t.start>i.end);i&&o.push(i),i=t}s.add(t.start,t.end,t.kind&&t.kind.value,o.length)}}else i=t,s.add(t.start,t.end,t.kind&&t.kind.value,o.length);return s.toIndentRanges()}