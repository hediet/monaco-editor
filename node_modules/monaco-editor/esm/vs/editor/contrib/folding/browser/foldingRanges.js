export const foldSourceAbbr={0:" ",1:"u",2:"r"};export const MAX_FOLDING_REGIONS=65535;export const MAX_LINE_NUMBER=16777215;const MASK_INDENT=4278190080;class BitField{constructor(e){const t=Math.ceil(e/32);this._states=new Uint32Array(t)}get(e){const t=e/32|0,s=e%32;return 0!=(this._states[t]&1<<s)}set(e,t){const s=e/32|0,n=e%32,r=this._states[s];this._states[s]=t?r|1<<n:r&~(1<<n)}}export class FoldingRegions{constructor(e,t,s){if(e.length!==t.length||e.length>65535)throw new Error("invalid startIndexes or endIndexes size");this._startIndexes=e,this._endIndexes=t,this._collapseStates=new BitField(e.length),this._userDefinedStates=new BitField(e.length),this._recoveredStates=new BitField(e.length),this._types=s,this._parentsComputed=!1}ensureParentIndices(){if(!this._parentsComputed){this._parentsComputed=!0;const e=[],t=(t,s)=>{const n=e[e.length-1];return this.getStartLineNumber(n)<=t&&this.getEndLineNumber(n)>=s};for(let s=0,n=this._startIndexes.length;s<n;s++){const n=this._startIndexes[s],r=this._endIndexes[s];if(n>16777215||r>16777215)throw new Error("startLineNumber or endLineNumber must not exceed 16777215");for(;e.length>0&&!t(n,r);)e.pop();const i=e.length>0?e[e.length-1]:-1;e.push(s),this._startIndexes[s]=n+((255&i)<<24),this._endIndexes[s]=r+((65280&i)<<16)}}}get length(){return this._startIndexes.length}getStartLineNumber(e){return 16777215&this._startIndexes[e]}getEndLineNumber(e){return 16777215&this._endIndexes[e]}getType(e){return this._types?this._types[e]:void 0}hasTypes(){return!!this._types}isCollapsed(e){return this._collapseStates.get(e)}setCollapsed(e,t){this._collapseStates.set(e,t)}isUserDefined(e){return this._userDefinedStates.get(e)}setUserDefined(e,t){return this._userDefinedStates.set(e,t)}isRecovered(e){return this._recoveredStates.get(e)}setRecovered(e,t){return this._recoveredStates.set(e,t)}getSource(e){return this.isUserDefined(e)?1:this.isRecovered(e)?2:0}setSource(e,t){1===t?(this.setUserDefined(e,!0),this.setRecovered(e,!1)):2===t?(this.setUserDefined(e,!1),this.setRecovered(e,!0)):(this.setUserDefined(e,!1),this.setRecovered(e,!1))}setCollapsedAllOfType(e,t){let s=!1;if(this._types)for(let n=0;n<this._types.length;n++)this._types[n]===e&&(this.setCollapsed(n,t),s=!0);return s}toRegion(e){return new FoldingRegion(this,e)}getParentIndex(e){this.ensureParentIndices();const t=((4278190080&this._startIndexes[e])>>>24)+((4278190080&this._endIndexes[e])>>>16);return 65535===t?-1:t}contains(e,t){return this.getStartLineNumber(e)<=t&&this.getEndLineNumber(e)>=t}findIndex(e){let t=0,s=this._startIndexes.length;if(0===s)return-1;for(;t<s;){const n=Math.floor((t+s)/2);e<this.getStartLineNumber(n)?s=n:t=n+1}return t-1}findRange(e){let t=this.findIndex(e);if(t>=0){if(this.getEndLineNumber(t)>=e)return t;for(t=this.getParentIndex(t);-1!==t;){if(this.contains(t,e))return t;t=this.getParentIndex(t)}}return-1}toString(){const e=[];for(let t=0;t<this.length;t++)e[t]=`[${foldSourceAbbr[this.getSource(t)]}${this.isCollapsed(t)?"+":"-"}] ${this.getStartLineNumber(t)}/${this.getEndLineNumber(t)}`;return e.join(", ")}toFoldRange(e){return{startLineNumber:16777215&this._startIndexes[e],endLineNumber:16777215&this._endIndexes[e],type:this._types?this._types[e]:void 0,isCollapsed:this.isCollapsed(e),source:this.getSource(e)}}static fromFoldRanges(e){const t=e.length,s=new Uint32Array(t),n=new Uint32Array(t);let r=[],i=!1;for(let o=0;o<t;o++){const t=e[o];s[o]=t.startLineNumber,n[o]=t.endLineNumber,r.push(t.type),t.type&&(i=!0)}i||(r=void 0);const o=new FoldingRegions(s,n,r);for(let s=0;s<t;s++)e[s].isCollapsed&&o.setCollapsed(s,!0),o.setSource(s,e[s].source);return o}static sanitizeAndMerge(e,t,s){s=null!=s?s:Number.MAX_VALUE;const n=(e,t)=>Array.isArray(e)?s=>s<t?e[s]:void 0:s=>s<t?e.toFoldRange(s):void 0,r=n(e,e.length),i=n(t,t.length);let o=0,d=0,h=r(0),u=i(0);const a=[];let l,g=0;const c=[];for(;h||u;){let e;if(u&&(!h||h.startLineNumber>=u.startLineNumber))h&&h.startLineNumber===u.startLineNumber?(1===u.source?e=u:(e=h,e.isCollapsed=u.isCollapsed&&h.endLineNumber===u.endLineNumber,e.source=0),h=r(++o)):(e=u,u.isCollapsed&&0===u.source&&(e.source=2)),u=i(++d);else{let t=d,s=u;for(;;){if(!s||s.startLineNumber>h.endLineNumber){e=h;break}if(1===s.source&&s.endLineNumber>h.endLineNumber)break;s=i(++t)}h=r(++o)}if(e){for(;l&&l.endLineNumber<e.startLineNumber;)l=a.pop();e.endLineNumber>e.startLineNumber&&e.startLineNumber>g&&e.endLineNumber<=s&&(!l||l.endLineNumber>=e.endLineNumber)&&(c.push(e),g=e.startLineNumber,l&&a.push(l),l=e)}}return c}}export class FoldingRegion{constructor(e,t){this.ranges=e,this.index=t}get startLineNumber(){return this.ranges.getStartLineNumber(this.index)}get endLineNumber(){return this.ranges.getEndLineNumber(this.index)}get regionIndex(){return this.index}get parentIndex(){return this.ranges.getParentIndex(this.index)}get isCollapsed(){return this.ranges.isCollapsed(this.index)}containedBy(e){return e.startLineNumber<=this.startLineNumber&&e.endLineNumber>=this.endLineNumber}containsLine(e){return this.startLineNumber<=e&&e<=this.endLineNumber}}