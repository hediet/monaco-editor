import{implies,expressionsAreEqualWithConstantSubstitution}from"../../contextkey/common/contextkey.js";export class KeybindingResolver{constructor(n,e,t){this._log=t,this._defaultKeybindings=n,this._defaultBoundCommands=new Map;for(const e of n){const n=e.command;n&&"-"!==n.charAt(0)&&this._defaultBoundCommands.set(n,!0)}this._map=new Map,this._lookupMap=new Map,this._keybindings=KeybindingResolver.handleRemovals([].concat(n).concat(e));for(let n=0,e=this._keybindings.length;n<e;n++){const e=this._keybindings[n];0!==e.chords.length&&(e.when&&0===e.when.type||this._addKeyPress(e.chords[0],e))}}static _isTargetedForRemoval(n,e,t,o){if(e&&n.chords[0]!==e)return!1;if(t&&n.chords[1]!==t)return!1;if(o&&1!==o.type){if(!n.when)return!1;if(!expressionsAreEqualWithConstantSubstitution(o,n.when))return!1}return!0}static handleRemovals(n){const e=new Map;for(let t=0,o=n.length;t<o;t++){const o=n[t];if(o.command&&"-"===o.command.charAt(0)){const n=o.command.substring(1);e.has(n)?e.get(n).push(o):e.set(n,[o])}}if(0===e.size)return n;const t=[];for(let o=0,i=n.length;o<i;o++){const i=n[o];if(!i.command||0===i.command.length){t.push(i);continue}if("-"===i.command.charAt(0))continue;const s=e.get(i.command);if(!s||!i.isDefault){t.push(i);continue}let r=!1;for(const n of s){const e=n.chords[0],t=n.chords[1],o=n.when;if(this._isTargetedForRemoval(i,e,t,o)){r=!0;break}}r||t.push(i)}return t}_addKeyPress(n,e){const t=this._map.get(n);if(void 0===t)return this._map.set(n,[e]),void this._addToLookupMap(e);for(let n=t.length-1;n>=0;n--){const o=t[n];if(o.command===e.command)continue;const i=o.chords.length>1,s=e.chords.length>1;i&&s&&o.chords[1]!==e.chords[1]||KeybindingResolver.whenIsEntirelyIncluded(o.when,e.when)&&this._removeFromLookupMap(o)}t.push(e),this._addToLookupMap(e)}_addToLookupMap(n){if(!n.command)return;let e=this._lookupMap.get(n.command);void 0===e?(e=[n],this._lookupMap.set(n.command,e)):e.push(n)}_removeFromLookupMap(n){if(!n.command)return;const e=this._lookupMap.get(n.command);if(void 0!==e)for(let t=0,o=e.length;t<o;t++)if(e[t]===n)return void e.splice(t,1)}static whenIsEntirelyIncluded(n,e){return!e||1===e.type||!(!n||1===n.type)&&implies(n,e)}getKeybindings(){return this._keybindings}lookupPrimaryKeybinding(n,e){const t=this._lookupMap.get(n);if(void 0===t||0===t.length)return null;if(1===t.length)return t[0];for(let n=t.length-1;n>=0;n--){const o=t[n];if(e.contextMatchesRules(o.when))return o}return t[t.length-1]}resolve(n,e,t){this._log(`| Resolving ${t}${e?` chorded from ${e}`:""}`);let o=null;if(null!==e){const n=this._map.get(e);if(void 0===n)return this._log("\\ No keybinding entries."),null;o=[];for(let e=0,i=n.length;e<i;e++){const i=n[e];i.chords[1]===t&&o.push(i)}}else{const n=this._map.get(t);if(void 0===n)return this._log("\\ No keybinding entries."),null;o=n}const i=this._findCommand(n,o);return i?null===e&&i.chords.length>1&&null!==i.chords[1]?(this._log(`\\ From ${o.length} keybinding entries, matched chord, when: ${printWhenExplanation(i.when)}, source: ${printSourceExplanation(i)}.`),{enterMultiChord:!0,leaveMultiChord:!1,commandId:null,commandArgs:null,bubble:!1}):(this._log(`\\ From ${o.length} keybinding entries, matched ${i.command}, when: ${printWhenExplanation(i.when)}, source: ${printSourceExplanation(i)}.`),{enterMultiChord:!1,leaveMultiChord:i.chords.length>1,commandId:i.command,commandArgs:i.commandArgs,bubble:i.bubble}):(this._log(`\\ From ${o.length} keybinding entries, no when clauses matched the context.`),null)}_findCommand(n,e){for(let t=e.length-1;t>=0;t--){const o=e[t];if(KeybindingResolver._contextMatchesRules(n,o.when))return o}return null}static _contextMatchesRules(n,e){return!e||e.evaluate(n)}}function printWhenExplanation(n){return n?`${n.serialize()}`:"no when condition"}function printSourceExplanation(n){return n.extensionId?n.isBuiltinExtension?`built-in extension ${n.extensionId}`:`user extension ${n.extensionId}`:n.isDefault?"built-in":"user"}