import{isFalsyOrEmpty,isNonEmptyArray}from"../../../base/common/arrays.js";import{DebounceEmitter}from"../../../base/common/event.js";import{Iterable}from"../../../base/common/iterator.js";import{ResourceMap}from"../../../base/common/map.js";import{Schemas}from"../../../base/common/network.js";import{URI}from"../../../base/common/uri.js";import{MarkerSeverity}from"./markers.js";export const unsupportedSchemas=new Set([Schemas.inMemory,Schemas.vscodeSourceControl,Schemas.walkThrough,Schemas.walkThroughSnippet]);class DoubleResourceMap{constructor(){this._byResource=new ResourceMap,this._byOwner=new Map}set(e,r,s){let t=this._byResource.get(e);t||(t=new Map,this._byResource.set(e,t)),t.set(r,s);let o=this._byOwner.get(r);o||(o=new ResourceMap,this._byOwner.set(r,o)),o.set(e,s)}get(e,r){const s=this._byResource.get(e);return null==s?void 0:s.get(r)}delete(e,r){let s=!1,t=!1;const o=this._byResource.get(e);o&&(s=o.delete(r));const n=this._byOwner.get(r);if(n&&(t=n.delete(e)),s!==t)throw new Error("illegal state");return s&&t}values(e){var r,s,t,o;return"string"==typeof e?null!==(s=null===(r=this._byOwner.get(e))||void 0===r?void 0:r.values())&&void 0!==s?s:Iterable.empty():URI.isUri(e)?null!==(o=null===(t=this._byResource.get(e))||void 0===t?void 0:t.values())&&void 0!==o?o:Iterable.empty():Iterable.map(Iterable.concat(...this._byOwner.values()),(e=>e[1]))}}class MarkerStats{constructor(e){this.errors=0,this.infos=0,this.warnings=0,this.unknowns=0,this._data=new ResourceMap,this._service=e,this._subscription=e.onMarkerChanged(this._update,this)}dispose(){this._subscription.dispose()}_update(e){for(const r of e){const e=this._data.get(r);e&&this._substract(e);const s=this._resourceStats(r);this._add(s),this._data.set(r,s)}}_resourceStats(e){const r={errors:0,warnings:0,infos:0,unknowns:0};if(unsupportedSchemas.has(e.scheme))return r;for(const{severity:s}of this._service.read({resource:e}))s===MarkerSeverity.Error?r.errors+=1:s===MarkerSeverity.Warning?r.warnings+=1:s===MarkerSeverity.Info?r.infos+=1:r.unknowns+=1;return r}_substract(e){this.errors-=e.errors,this.warnings-=e.warnings,this.infos-=e.infos,this.unknowns-=e.unknowns}_add(e){this.errors+=e.errors,this.warnings+=e.warnings,this.infos+=e.infos,this.unknowns+=e.unknowns}}export class MarkerService{constructor(){this._onMarkerChanged=new DebounceEmitter({delay:0,merge:MarkerService._merge}),this.onMarkerChanged=this._onMarkerChanged.event,this._data=new DoubleResourceMap,this._stats=new MarkerStats(this)}dispose(){this._stats.dispose(),this._onMarkerChanged.dispose()}remove(e,r){for(const s of r||[])this.changeOne(e,s,[])}changeOne(e,r,s){if(isFalsyOrEmpty(s))this._data.delete(r,e)&&this._onMarkerChanged.fire([r]);else{const t=[];for(const o of s){const s=MarkerService._toMarker(e,r,o);s&&t.push(s)}this._data.set(r,e,t),this._onMarkerChanged.fire([r])}}static _toMarker(e,r,s){let{code:t,severity:o,message:n,source:a,startLineNumber:i,startColumn:c,endLineNumber:u,endColumn:h,relatedInformation:f,tags:m}=s;if(n)return i=i>0?i:1,c=c>0?c:1,u=u>=i?u:i,h=h>0?h:c,{resource:r,owner:e,code:t,severity:o,message:n,source:a,startLineNumber:i,startColumn:c,endLineNumber:u,endColumn:h,relatedInformation:f,tags:m}}changeAll(e,r){const s=[],t=this._data.values(e);if(t)for(const r of t){const t=Iterable.first(r);t&&(s.push(t.resource),this._data.delete(t.resource,e))}if(isNonEmptyArray(r)){const t=new ResourceMap;for(const{resource:o,marker:n}of r){const r=MarkerService._toMarker(e,o,n);if(!r)continue;const a=t.get(o);a?a.push(r):(t.set(o,[r]),s.push(o))}for(const[r,s]of t)this._data.set(r,e,s)}s.length>0&&this._onMarkerChanged.fire(s)}read(e=Object.create(null)){let{owner:r,resource:s,severities:t,take:o}=e;if((!o||o<0)&&(o=-1),r&&s){const e=this._data.get(s,r);if(e){const r=[];for(const s of e)if(MarkerService._accept(s,t)){const e=r.push(s);if(o>0&&e===o)break}return r}return[]}if(r||s){const e=this._data.values(null!=s?s:r),n=[];for(const r of e)for(const e of r)if(MarkerService._accept(e,t)){const r=n.push(e);if(o>0&&r===o)return n}return n}{const e=[];for(const r of this._data.values())for(const s of r)if(MarkerService._accept(s,t)){const r=e.push(s);if(o>0&&r===o)return e}return e}}static _accept(e,r){return void 0===r||(r&e.severity)===e.severity}static _merge(e){const r=new ResourceMap;for(const s of e)for(const e of s)r.set(e,!0);return Array.from(r.keys())}}