import{IdleValue}from"../../../base/common/async.js";import{illegalState}from"../../../base/common/errors.js";import{toDisposable}from"../../../base/common/lifecycle.js";import{SyncDescriptor}from"./descriptors.js";import{Graph}from"./graph.js";import{IInstantiationService,_util}from"./instantiation.js";import{ServiceCollection}from"./serviceCollection.js";import{LinkedList}from"../../../base/common/linkedList.js";const _enableAllTracing=!1;class CyclicDependencyError extends Error{constructor(e){var t;super("cyclic dependency between services"),this.message=null!==(t=e.findCycleSlow())&&void 0!==t?t:`UNABLE to detect cycle, dumping graph: \n${e.toString()}`}}export class InstantiationService{constructor(e=new ServiceCollection,t=!1,n,r=!1){var i;this._services=e,this._strict=t,this._parent=n,this._enableTracing=r,this._activeInstantiations=new Set,this._services.set(IInstantiationService,this),this._globalGraph=r?null!==(i=null==n?void 0:n._globalGraph)&&void 0!==i?i:new Graph((e=>e)):void 0}createChild(e){return new InstantiationService(e,this._strict,this,this._enableTracing)}invokeFunction(e,...t){const n=Trace.traceInvocation(this._enableTracing,e);let r=!1;try{return e({get:e=>{if(r)throw illegalState("service accessor is only valid during the invocation of its target method");const t=this._getOrCreateServiceInstance(e,n);if(!t)throw new Error(`[invokeFunction] unknown service '${e}'`);return t}},...t)}finally{r=!0,n.stop()}}createInstance(e,...t){let n,r;return e instanceof SyncDescriptor?(n=Trace.traceCreation(this._enableTracing,e.ctor),r=this._createInstance(e.ctor,e.staticArguments.concat(t),n)):(n=Trace.traceCreation(this._enableTracing,e),r=this._createInstance(e,t,n)),n.stop(),r}_createInstance(e,t=[],n){const r=_util.getServiceDependencies(e).sort(((e,t)=>e.index-t.index)),i=[];for(const t of r){const r=this._getOrCreateServiceInstance(t.id,n);r||this._throwIfStrict(`[createInstance] ${e.name} depends on UNKNOWN service ${t.id}.`,!1),i.push(r)}const s=r.length>0?r[0].index:t.length;if(t.length!==s){console.trace(`[createInstance] First service dependency of ${e.name} at position ${s+1} conflicts with ${t.length} static arguments`);const n=s-t.length;t=n>0?t.concat(new Array(n)):t.slice(0,s)}return Reflect.construct(e,t.concat(i))}_setServiceInstance(e,t){if(this._services.get(e)instanceof SyncDescriptor)this._services.set(e,t);else{if(!this._parent)throw new Error("illegalState - setting UNKNOWN service instance");this._parent._setServiceInstance(e,t)}}_getServiceInstanceOrDescriptor(e){const t=this._services.get(e);return!t&&this._parent?this._parent._getServiceInstanceOrDescriptor(e):t}_getOrCreateServiceInstance(e,t){this._globalGraph&&this._globalGraphImplicitDependency&&this._globalGraph.insertEdge(this._globalGraphImplicitDependency,String(e));const n=this._getServiceInstanceOrDescriptor(e);return n instanceof SyncDescriptor?this._safeCreateAndCacheServiceInstance(e,n,t.branch(e,!0)):(t.branch(e,!1),n)}_safeCreateAndCacheServiceInstance(e,t,n){if(this._activeInstantiations.has(e))throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`);this._activeInstantiations.add(e);try{return this._createAndCacheServiceInstance(e,t,n)}finally{this._activeInstantiations.delete(e)}}_createAndCacheServiceInstance(e,t,n){var r;const i=new Graph((e=>e.id.toString()));let s=0;const c=[{id:e,desc:t,_trace:n}];for(;c.length;){const t=c.pop();if(i.lookupOrInsertNode(t),s++>1e3)throw new CyclicDependencyError(i);for(const n of _util.getServiceDependencies(t.desc.ctor)){const s=this._getServiceInstanceOrDescriptor(n.id);if(s||this._throwIfStrict(`[createInstance] ${e} depends on ${n.id} which is NOT registered.`,!0),null===(r=this._globalGraph)||void 0===r||r.insertEdge(String(t.id),String(n.id)),s instanceof SyncDescriptor){const e={id:n.id,desc:s,_trace:t._trace.branch(n.id,!0)};i.insertEdge(t,e),c.push(e)}}}for(;;){const e=i.roots();if(0===e.length){if(!i.isEmpty())throw new CyclicDependencyError(i);break}for(const{data:t}of e){if(this._getServiceInstanceOrDescriptor(t.id)instanceof SyncDescriptor){const e=this._createServiceInstanceWithOwner(t.id,t.desc.ctor,t.desc.staticArguments,t.desc.supportsDelayedInstantiation,t._trace);this._setServiceInstance(t.id,e)}i.removeNode(t)}}return this._getServiceInstanceOrDescriptor(e)}_createServiceInstanceWithOwner(e,t,n=[],r,i){if(this._services.get(e)instanceof SyncDescriptor)return this._createServiceInstance(e,t,n,r,i);if(this._parent)return this._parent._createServiceInstanceWithOwner(e,t,n,r,i);throw new Error(`illegalState - creating UNKNOWN service instance ${t.name}`)}_createServiceInstance(e,t,n=[],r,i){if(r){const r=new InstantiationService(void 0,this._strict,this,this._enableTracing);r._globalGraphImplicitDependency=String(e);const s=new Map,c=new IdleValue((()=>{const e=r._createInstance(t,n,i);for(const[t,n]of s){const r=e[t];if("function"==typeof r)for(const t of n)r.apply(e,t)}return s.clear(),e}));return new Proxy(Object.create(null),{get(e,t){if(!c.isInitialized&&"string"==typeof t&&(t.startsWith("onDid")||t.startsWith("onWill"))){let e=s.get(t);return e||(e=new LinkedList,s.set(t,e)),(t,n,r)=>{const i=e.push([t,n,r]);return toDisposable(i)}}if(t in e)return e[t];const n=c.value;let r=n[t];return"function"!=typeof r||(r=r.bind(n),e[t]=r),r},set:(e,t,n)=>(c.value[t]=n,!0),getPrototypeOf:e=>t.prototype})}return this._createInstance(t,n,i)}_throwIfStrict(e,t){if(t&&console.warn(e),this._strict)throw new Error(e)}}class Trace{static traceInvocation(e,t){return e?new Trace(2,t.name||(new Error).stack.split("\n").slice(3,4).join("\n")):Trace._None}static traceCreation(e,t){return e?new Trace(1,t.name):Trace._None}constructor(e,t){this.type=e,this.name=t,this._start=Date.now(),this._dep=[]}branch(e,t){const n=new Trace(3,e.toString());return this._dep.push([e,t,n]),n}stop(){const e=Date.now()-this._start;Trace._totals+=e;let t=!1;const n=[`${1===this.type?"CREATE":"CALL"} ${this.name}`,`${function e(n,r){const i=[],s=new Array(n+1).join("\t");for(const[c,a,o]of r._dep)if(a&&o){t=!0,i.push(`${s}CREATES -> ${c}`);const r=e(n+1,o);r&&i.push(r)}else i.push(`${s}uses -> ${c}`);return i.join("\n")}(1,this)}`,`DONE, took ${e.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`];(e>2||t)&&Trace.all.add(n.join("\n"))}}Trace.all=new Set,Trace._None=new class extends Trace{constructor(){super(0,null)}stop(){}branch(){return this}},Trace._totals=0;export{Trace};