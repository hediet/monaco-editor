export class Node{constructor(o,t){this.key=o,this.data=t,this.incoming=new Map,this.outgoing=new Map}}export class Graph{constructor(o){this._hashFn=o,this._nodes=new Map}roots(){const o=[];for(const t of this._nodes.values())0===t.outgoing.size&&o.push(t);return o}insertEdge(o,t){const n=this.lookupOrInsertNode(o),s=this.lookupOrInsertNode(t);n.outgoing.set(s.key,s),s.incoming.set(n.key,n)}removeNode(o){const t=this._hashFn(o);this._nodes.delete(t);for(const o of this._nodes.values())o.outgoing.delete(t),o.incoming.delete(t)}lookupOrInsertNode(o){const t=this._hashFn(o);let n=this._nodes.get(t);return n||(n=new Node(t,o),this._nodes.set(t,n)),n}isEmpty(){return 0===this._nodes.size}toString(){const o=[];for(const[t,n]of this._nodes)o.push(`${t}\n\t(-> incoming)[${[...n.incoming.keys()].join(", ")}]\n\t(outgoing ->)[${[...n.outgoing.keys()].join(",")}]\n`);return o.join("\n")}findCycleSlow(){for(const[o,t]of this._nodes){const n=new Set([o]),s=this._findCycle(t,n);if(s)return s}}_findCycle(o,t){for(const[n,s]of o.outgoing){if(t.has(n))return[...t,n].join(" -> ");t.add(n);const o=this._findCycle(s,t);if(o)return o;t.delete(n)}}}