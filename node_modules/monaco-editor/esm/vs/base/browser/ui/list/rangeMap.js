import{Range}from"../../../common/range.js";export function groupIntersect(t,e){const n=[];for(const r of e){if(t.start>=r.range.end)continue;if(t.end<r.range.start)break;const e=Range.intersect(t,r.range);Range.isEmpty(e)||n.push({range:e,size:r.size})}return n}export function shift({start:t,end:e},n){return{start:t+n,end:e+n}}export function consolidate(t){const e=[];let n=null;for(const r of t){const t=r.range.start,s=r.range.end,o=r.size;n&&o===n.size?n.range.end=s:(n={range:{start:t,end:s},size:o},e.push(n))}return e}function concat(...t){return consolidate(t.reduce(((t,e)=>t.concat(e)),[]))}export class RangeMap{constructor(){this.groups=[],this._size=0}splice(t,e,n=[]){const r=n.length-e,s=groupIntersect({start:0,end:t},this.groups),o=groupIntersect({start:t+e,end:Number.POSITIVE_INFINITY},this.groups).map((t=>({range:shift(t.range,r),size:t.size}))),i=n.map(((e,n)=>({range:{start:t+n,end:t+n+1},size:e.size})));this.groups=concat(s,i,o),this._size=this.groups.reduce(((t,e)=>t+e.size*(e.range.end-e.range.start)),0)}get count(){const t=this.groups.length;return t?this.groups[t-1].range.end:0}get size(){return this._size}indexAt(t){if(t<0)return-1;let e=0,n=0;for(const r of this.groups){const s=r.range.end-r.range.start,o=n+s*r.size;if(t<o)return e+Math.floor((t-n)/r.size);e+=s,n=o}return e}indexAfter(t){return Math.min(this.indexAt(t)+1,this.count)}positionAt(t){if(t<0)return-1;let e=0,n=0;for(const r of this.groups){const s=r.range.end-r.range.start,o=n+s;if(t<o)return e+(t-n)*r.size;e+=s*r.size,n=o}return-1}}