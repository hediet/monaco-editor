var _a,_b;class ResourceMapEntry{constructor(t,e){this.uri=t,this.value=e}}class ResourceMap{constructor(t,e){this[_a]="ResourceMap",t instanceof ResourceMap?(this.map=new Map(t.map),this.toKey=null!=e?e:ResourceMap.defaultToKey):(this.map=new Map,this.toKey=null!=t?t:ResourceMap.defaultToKey)}set(t,e){return this.map.set(this.toKey(t),new ResourceMapEntry(t,e)),this}get(t){var e;return null===(e=this.map.get(this.toKey(t)))||void 0===e?void 0:e.value}has(t){return this.map.has(this.toKey(t))}get size(){return this.map.size}clear(){this.map.clear()}delete(t){return this.map.delete(this.toKey(t))}forEach(t,e){void 0!==e&&(t=t.bind(e));for(const[e,i]of this.map)t(i.value,i.uri,this)}*values(){for(const t of this.map.values())yield t.value}*keys(){for(const t of this.map.values())yield t.uri}*entries(){for(const t of this.map.values())yield[t.uri,t.value]}*[(_a=Symbol.toStringTag,Symbol.iterator)](){for(const[,t]of this.map)yield[t.uri,t.value]}}ResourceMap.defaultToKey=t=>t.toString();export{ResourceMap};export class LinkedMap{constructor(){this[_b]="LinkedMap",this._map=new Map,this._head=void 0,this._tail=void 0,this._size=0,this._state=0}clear(){this._map.clear(),this._head=void 0,this._tail=void 0,this._size=0,this._state++}isEmpty(){return!this._head&&!this._tail}get size(){return this._size}get first(){var t;return null===(t=this._head)||void 0===t?void 0:t.value}get last(){var t;return null===(t=this._tail)||void 0===t?void 0:t.value}has(t){return this._map.has(t)}get(t,e=0){const i=this._map.get(t);if(i)return 0!==e&&this.touch(i,e),i.value}set(t,e,i=0){let s=this._map.get(t);if(s)s.value=e,0!==i&&this.touch(s,i);else{switch(s={key:t,value:e,next:void 0,previous:void 0},i){case 0:case 2:default:this.addItemLast(s);break;case 1:this.addItemFirst(s)}this._map.set(t,s),this._size++}return this}delete(t){return!!this.remove(t)}remove(t){const e=this._map.get(t);if(e)return this._map.delete(t),this.removeItem(e),this._size--,e.value}shift(){if(!this._head&&!this._tail)return;if(!this._head||!this._tail)throw new Error("Invalid list");const t=this._head;return this._map.delete(t.key),this.removeItem(t),this._size--,t.value}forEach(t,e){const i=this._state;let s=this._head;for(;s;){if(e?t.bind(e)(s.value,s.key,this):t(s.value,s.key,this),this._state!==i)throw new Error("LinkedMap got modified during iteration.");s=s.next}}keys(){const t=this,e=this._state;let i=this._head;const s={[Symbol.iterator]:()=>s,next(){if(t._state!==e)throw new Error("LinkedMap got modified during iteration.");if(i){const t={value:i.key,done:!1};return i=i.next,t}return{value:void 0,done:!0}}};return s}values(){const t=this,e=this._state;let i=this._head;const s={[Symbol.iterator]:()=>s,next(){if(t._state!==e)throw new Error("LinkedMap got modified during iteration.");if(i){const t={value:i.value,done:!1};return i=i.next,t}return{value:void 0,done:!0}}};return s}entries(){const t=this,e=this._state;let i=this._head;const s={[Symbol.iterator]:()=>s,next(){if(t._state!==e)throw new Error("LinkedMap got modified during iteration.");if(i){const t={value:[i.key,i.value],done:!1};return i=i.next,t}return{value:void 0,done:!0}}};return s}[(_b=Symbol.toStringTag,Symbol.iterator)](){return this.entries()}trimOld(t){if(t>=this.size)return;if(0===t)return void this.clear();let e=this._head,i=this.size;for(;e&&i>t;)this._map.delete(e.key),e=e.next,i--;this._head=e,this._size=i,e&&(e.previous=void 0),this._state++}addItemFirst(t){if(this._head||this._tail){if(!this._head)throw new Error("Invalid list");t.next=this._head,this._head.previous=t}else this._tail=t;this._head=t,this._state++}addItemLast(t){if(this._head||this._tail){if(!this._tail)throw new Error("Invalid list");t.previous=this._tail,this._tail.next=t}else this._head=t;this._tail=t,this._state++}removeItem(t){if(t===this._head&&t===this._tail)this._head=void 0,this._tail=void 0;else if(t===this._head){if(!t.next)throw new Error("Invalid list");t.next.previous=void 0,this._head=t.next}else if(t===this._tail){if(!t.previous)throw new Error("Invalid list");t.previous.next=void 0,this._tail=t.previous}else{const e=t.next,i=t.previous;if(!e||!i)throw new Error("Invalid list");e.previous=i,i.next=e}t.next=void 0,t.previous=void 0,this._state++}touch(t,e){if(!this._head||!this._tail)throw new Error("Invalid list");if(1===e||2===e)if(1===e){if(t===this._head)return;const e=t.next,i=t.previous;t===this._tail?(i.next=void 0,this._tail=i):(e.previous=i,i.next=e),t.previous=void 0,t.next=this._head,this._head.previous=t,this._head=t,this._state++}else if(2===e){if(t===this._tail)return;const e=t.next,i=t.previous;t===this._head?(e.previous=void 0,this._head=e):(e.previous=i,i.next=e),t.next=void 0,t.previous=this._tail,this._tail.next=t,this._tail=t,this._state++}}toJSON(){const t=[];return this.forEach(((e,i)=>{t.push([i,e])})),t}fromJSON(t){this.clear();for(const[e,i]of t)this.set(e,i)}}export class LRUCache extends LinkedMap{constructor(t,e=1){super(),this._limit=t,this._ratio=Math.min(Math.max(0,e),1)}get limit(){return this._limit}set limit(t){this._limit=t,this.checkTrim()}get(t,e=2){return super.get(t,e)}peek(t){return super.get(t,0)}set(t,e){return super.set(t,e,2),this.checkTrim(),this}checkTrim(){this.size>this._limit&&this.trimOld(Math.round(this._limit*this._ratio))}}