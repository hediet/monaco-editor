export function tail(t,e=0){return t[t.length-(1+e)]}export function tail2(t){if(0===t.length)throw new Error("Invalid tail call");return[t.slice(0,t.length-1),t[t.length-1]]}export function equals(t,e,r=((t,e)=>t===e)){if(t===e)return!0;if(!t||!e)return!1;if(t.length!==e.length)return!1;for(let n=0,i=t.length;n<i;n++)if(!r(t[n],e[n]))return!1;return!0}export function removeFastWithoutKeepingOrder(t,e){const r=t.length-1;e<r&&(t[e]=t[r]),t.pop()}export function binarySearch(t,e,r){return binarySearch2(t.length,(n=>r(t[n],e)))}export function binarySearch2(t,e){let r=0,n=t-1;for(;r<=n;){const t=(r+n)/2|0,i=e(t);if(i<0)r=t+1;else{if(!(i>0))return t;n=t-1}}return-(r+1)}export function findFirstInSorted(t,e){let r=0,n=t.length;if(0===n)return 0;for(;r<n;){const i=Math.floor((r+n)/2);e(t[i])?n=i:r=i+1}return r}export function quickSelect(t,e,r){if((t|=0)>=e.length)throw new TypeError("invalid index");const n=e[Math.floor(e.length*Math.random())],i=[],s=[],o=[];for(const t of e){const e=r(t,n);e<0?i.push(t):e>0?s.push(t):o.push(t)}return t<i.length?quickSelect(t,i,r):t<i.length+o.length?o[0]:quickSelect(t-(i.length+o.length),s,r)}export function groupBy(t,e){const r=[];let n;for(const i of t.slice(0).sort(e))n&&0===e(n[0],i)?n.push(i):(n=[i],r.push(n));return r}export function coalesce(t){return t.filter((t=>!!t))}export function coalesceInPlace(t){let e=0;for(let r=0;r<t.length;r++)t[r]&&(t[e]=t[r],e+=1);t.length=e}export function isFalsyOrEmpty(t){return!Array.isArray(t)||0===t.length}export function isNonEmptyArray(t){return Array.isArray(t)&&t.length>0}export function distinct(t,e=(t=>t)){const r=new Set;return t.filter((t=>{const n=e(t);return!r.has(n)&&(r.add(n),!0)}))}export function findLast(t,e){const r=lastIndex(t,e);if(-1!==r)return t[r]}export function lastIndex(t,e){for(let r=t.length-1;r>=0;r--)if(e(t[r]))return r;return-1}export function firstOrDefault(t,e){return t.length>0?t[0]:e}export function range(t,e){let r="number"==typeof e?t:0;"number"==typeof e?r=t:(r=0,e=t);const n=[];if(r<=e)for(let t=r;t<e;t++)n.push(t);else for(let t=r;t>e;t--)n.push(t);return n}export function arrayInsert(t,e,r){const n=t.slice(0,e),i=t.slice(e);return n.concat(r,i)}export function pushToStart(t,e){const r=t.indexOf(e);r>-1&&(t.splice(r,1),t.unshift(e))}export function pushToEnd(t,e){const r=t.indexOf(e);r>-1&&(t.splice(r,1),t.push(e))}export function pushMany(t,e){for(const r of e)t.push(r)}export function asArray(t){return Array.isArray(t)?t:[t]}export function insertInto(t,e,r){const n=getActualStartIndex(t,e),i=t.length,s=r.length;t.length=i+s;for(let e=i-1;e>=n;e--)t[e+s]=t[e];for(let e=0;e<s;e++)t[e+n]=r[e]}export function splice(t,e,r,n){const i=getActualStartIndex(t,e),s=t.splice(i,r);return insertInto(t,i,n),s}function getActualStartIndex(t,e){return e<0?Math.max(e+t.length,0):Math.min(e,t.length)}export var CompareResult;!function(t){t.isLessThan=function(t){return t<0},t.isGreaterThan=function(t){return t>0},t.isNeitherLessOrGreaterThan=function(t){return 0===t},t.greaterThan=1,t.lessThan=-1,t.neitherLessOrGreaterThan=0}(CompareResult||(CompareResult={}));export function compareBy(t,e){return(r,n)=>e(t(r),t(n))}export const numberComparator=(t,e)=>t-e;export function findMaxBy(t,e){if(0===t.length)return;let r=t[0];for(let n=1;n<t.length;n++){const i=t[n];e(i,r)>0&&(r=i)}return r}export function findLastMaxBy(t,e){if(0===t.length)return;let r=t[0];for(let n=1;n<t.length;n++){const i=t[n];e(i,r)>=0&&(r=i)}return r}export function findMinBy(t,e){return findMaxBy(t,((t,r)=>-e(t,r)))}export class ArrayQueue{constructor(t){this.items=t,this.firstIdx=0,this.lastIdx=this.items.length-1}get length(){return this.lastIdx-this.firstIdx+1}takeWhile(t){let e=this.firstIdx;for(;e<this.items.length&&t(this.items[e]);)e++;const r=e===this.firstIdx?null:this.items.slice(this.firstIdx,e);return this.firstIdx=e,r}takeFromEndWhile(t){let e=this.lastIdx;for(;e>=0&&t(this.items[e]);)e--;const r=e===this.lastIdx?null:this.items.slice(e+1,this.lastIdx+1);return this.lastIdx=e,r}peek(){if(0!==this.length)return this.items[this.firstIdx]}dequeue(){const t=this.items[this.firstIdx];return this.firstIdx++,t}takeCount(t){const e=this.items.slice(this.firstIdx,this.firstIdx+t);return this.firstIdx+=t,e}}class CallbackIterable{constructor(t){this.iterate=t}toArray(){const t=[];return this.iterate((e=>(t.push(e),!0))),t}filter(t){return new CallbackIterable((e=>this.iterate((r=>!t(r)||e(r)))))}map(t){return new CallbackIterable((e=>this.iterate((r=>e(t(r))))))}findLast(t){let e;return this.iterate((r=>(t(r)&&(e=r),!0))),e}findLastMaxBy(t){let e,r=!0;return this.iterate((n=>((r||CompareResult.isGreaterThan(t(n,e)))&&(r=!1,e=n),!0))),e}}CallbackIterable.empty=new CallbackIterable((t=>{}));export{CallbackIterable};