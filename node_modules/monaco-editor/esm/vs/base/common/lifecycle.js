import{once}from"./functional.js";import{Iterable}from"./iterator.js";const TRACK_DISPOSABLES=!1;let disposableTracker=null;export function setDisposableTracker(s){disposableTracker=s}function trackDisposable(s){return null==disposableTracker||disposableTracker.trackDisposable(s),s}function markAsDisposed(s){null==disposableTracker||disposableTracker.markAsDisposed(s)}function setParentOfDisposable(s,e){null==disposableTracker||disposableTracker.setParent(s,e)}function setParentOfDisposables(s,e){if(disposableTracker)for(const t of s)disposableTracker.setParent(t,e)}export function markAsSingleton(s){return null==disposableTracker||disposableTracker.markAsSingleton(s),s}export function isDisposable(s){return"function"==typeof s.dispose&&0===s.dispose.length}export function dispose(s){if(Iterable.is(s)){const e=[];for(const t of s)if(t)try{t.dispose()}catch(s){e.push(s)}if(1===e.length)throw e[0];if(e.length>1)throw new AggregateError(e,"Encountered errors while disposing of store");return Array.isArray(s)?[]:s}if(s)return s.dispose(),s}export function combinedDisposable(...s){const e=toDisposable((()=>dispose(s)));return setParentOfDisposables(s,e),e}export function toDisposable(s){const e=trackDisposable({dispose:once((()=>{markAsDisposed(e),s()}))});return e}class DisposableStore{constructor(){this._toDispose=new Set,this._isDisposed=!1,trackDisposable(this)}dispose(){this._isDisposed||(markAsDisposed(this),this._isDisposed=!0,this.clear())}get isDisposed(){return this._isDisposed}clear(){if(0!==this._toDispose.size)try{dispose(this._toDispose)}finally{this._toDispose.clear()}}add(s){if(!s)return s;if(s===this)throw new Error("Cannot register a disposable on itself!");return setParentOfDisposable(s,this),this._isDisposed?DisposableStore.DISABLE_DISPOSED_WARNING||console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack):this._toDispose.add(s),s}}DisposableStore.DISABLE_DISPOSED_WARNING=!1;export{DisposableStore};class Disposable{constructor(){this._store=new DisposableStore,trackDisposable(this),setParentOfDisposable(this._store,this)}dispose(){markAsDisposed(this),this._store.dispose()}_register(s){if(s===this)throw new Error("Cannot register a disposable on itself!");return this._store.add(s)}}Disposable.None=Object.freeze({dispose(){}});export{Disposable};export class MutableDisposable{constructor(){this._isDisposed=!1,trackDisposable(this)}get value(){return this._isDisposed?void 0:this._value}set value(s){var e;this._isDisposed||s===this._value||(null===(e=this._value)||void 0===e||e.dispose(),s&&setParentOfDisposable(s,this),this._value=s)}clear(){this.value=void 0}dispose(){var s;this._isDisposed=!0,markAsDisposed(this),null===(s=this._value)||void 0===s||s.dispose(),this._value=void 0}clearAndLeak(){const s=this._value;return this._value=void 0,s&&setParentOfDisposable(s,null),s}}export class RefCountedDisposable{constructor(s){this._disposable=s,this._counter=1}acquire(){return this._counter++,this}release(){return 0==--this._counter&&this._disposable.dispose(),this}}export class SafeDisposable{constructor(){this.dispose=()=>{},this.unset=()=>{},this.isset=()=>!1,trackDisposable(this)}set(s){let e=s;return this.unset=()=>e=void 0,this.isset=()=>void 0!==e,this.dispose=()=>{e&&(e(),e=void 0,markAsDisposed(this))},this}}export class ImmortalReference{constructor(s){this.object=s}dispose(){}}export class DisposableMap{constructor(){this._store=new Map,this._isDisposed=!1,trackDisposable(this)}dispose(){markAsDisposed(this),this._isDisposed=!0,this.clearAndDisposeAll()}clearAndDisposeAll(){if(this._store.size)try{dispose(this._store.values())}finally{this._store.clear()}}get(s){return this._store.get(s)}set(s,e,t=!1){var i;this._isDisposed&&console.warn(new Error("Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!").stack),t||null===(i=this._store.get(s))||void 0===i||i.dispose(),this._store.set(s,e)}[Symbol.iterator](){return this._store[Symbol.iterator]()}}