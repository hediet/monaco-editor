import{DiffChange}from"./diffChange.js";import{stringHash}from"../hash.js";export class StringDiffSequence{constructor(t){this.source=t}getElements(){const t=this.source,i=new Int32Array(t.length);for(let e=0,n=t.length;e<n;e++)i[e]=t.charCodeAt(e);return i}}export function stringDiff(t,i,e){return new LcsDiff(new StringDiffSequence(t),new StringDiffSequence(i)).ComputeDiff(e).changes}class Debug{static Assert(t,i){if(!t)throw new Error(i)}}class MyArray{static Copy(t,i,e,n,r){for(let s=0;s<r;s++)e[n+s]=t[i+s]}static Copy2(t,i,e,n,r){for(let s=0;s<r;s++)e[n+s]=t[i+s]}}class DiffChangeHelper{constructor(){this.m_changes=[],this.m_originalStart=1073741824,this.m_modifiedStart=1073741824,this.m_originalCount=0,this.m_modifiedCount=0}MarkNextChange(){(this.m_originalCount>0||this.m_modifiedCount>0)&&this.m_changes.push(new DiffChange(this.m_originalStart,this.m_originalCount,this.m_modifiedStart,this.m_modifiedCount)),this.m_originalCount=0,this.m_modifiedCount=0,this.m_originalStart=1073741824,this.m_modifiedStart=1073741824}AddOriginalElement(t,i){this.m_originalStart=Math.min(this.m_originalStart,t),this.m_modifiedStart=Math.min(this.m_modifiedStart,i),this.m_originalCount++}AddModifiedElement(t,i){this.m_originalStart=Math.min(this.m_originalStart,t),this.m_modifiedStart=Math.min(this.m_modifiedStart,i),this.m_modifiedCount++}getChanges(){return(this.m_originalCount>0||this.m_modifiedCount>0)&&this.MarkNextChange(),this.m_changes}getReverseChanges(){return(this.m_originalCount>0||this.m_modifiedCount>0)&&this.MarkNextChange(),this.m_changes.reverse(),this.m_changes}}export class LcsDiff{constructor(t,i,e=null){this.ContinueProcessingPredicate=e,this._originalSequence=t,this._modifiedSequence=i;const[n,r,s]=LcsDiff._getElements(t),[o,a,h]=LcsDiff._getElements(i);this._hasStrings=s&&h,this._originalStringElements=n,this._originalElementsOrHash=r,this._modifiedStringElements=o,this._modifiedElementsOrHash=a,this.m_forwardHistory=[],this.m_reverseHistory=[]}static _isStringArray(t){return t.length>0&&"string"==typeof t[0]}static _getElements(t){const i=t.getElements();if(LcsDiff._isStringArray(i)){const t=new Int32Array(i.length);for(let e=0,n=i.length;e<n;e++)t[e]=stringHash(i[e],0);return[i,t,!0]}return i instanceof Int32Array?[[],i,!1]:[[],new Int32Array(i),!1]}ElementsAreEqual(t,i){return this._originalElementsOrHash[t]===this._modifiedElementsOrHash[i]&&(!this._hasStrings||this._originalStringElements[t]===this._modifiedStringElements[i])}ElementsAreStrictEqual(t,i){return!!this.ElementsAreEqual(t,i)&&LcsDiff._getStrictElement(this._originalSequence,t)===LcsDiff._getStrictElement(this._modifiedSequence,i)}static _getStrictElement(t,i){return"function"==typeof t.getStrictElement?t.getStrictElement(i):null}OriginalElementsAreEqual(t,i){return this._originalElementsOrHash[t]===this._originalElementsOrHash[i]&&(!this._hasStrings||this._originalStringElements[t]===this._originalStringElements[i])}ModifiedElementsAreEqual(t,i){return this._modifiedElementsOrHash[t]===this._modifiedElementsOrHash[i]&&(!this._hasStrings||this._modifiedStringElements[t]===this._modifiedStringElements[i])}ComputeDiff(t){return this._ComputeDiff(0,this._originalElementsOrHash.length-1,0,this._modifiedElementsOrHash.length-1,t)}_ComputeDiff(t,i,e,n,r){const s=[!1];let o=this.ComputeDiffRecursive(t,i,e,n,s);return r&&(o=this.PrettifyChanges(o)),{quitEarly:s[0],changes:o}}ComputeDiffRecursive(t,i,e,n,r){for(r[0]=!1;t<=i&&e<=n&&this.ElementsAreEqual(t,e);)t++,e++;for(;i>=t&&n>=e&&this.ElementsAreEqual(i,n);)i--,n--;if(t>i||e>n){let r;return e<=n?(Debug.Assert(t===i+1,"originalStart should only be one more than originalEnd"),r=[new DiffChange(t,0,e,n-e+1)]):t<=i?(Debug.Assert(e===n+1,"modifiedStart should only be one more than modifiedEnd"),r=[new DiffChange(t,i-t+1,e,0)]):(Debug.Assert(t===i+1,"originalStart should only be one more than originalEnd"),Debug.Assert(e===n+1,"modifiedStart should only be one more than modifiedEnd"),r=[]),r}const s=[0],o=[0],a=this.ComputeRecursionPoint(t,i,e,n,s,o,r),h=s[0],l=o[0];if(null!==a)return a;if(!r[0]){const s=this.ComputeDiffRecursive(t,h,e,l,r);let o=[];return o=r[0]?[new DiffChange(h+1,i-(h+1)+1,l+1,n-(l+1)+1)]:this.ComputeDiffRecursive(h+1,i,l+1,n,r),this.ConcatenateChanges(s,o)}return[new DiffChange(t,i-t+1,e,n-e+1)]}WALKTRACE(t,i,e,n,r,s,o,a,h,l,g,d,f,m,u,c,S,_){let E=null,C=null,y=new DiffChangeHelper,A=i,L=e,D=f[0]-c[0]-n,p=-1073741824,M=this.m_forwardHistory.length-1;do{const i=D+t;i===A||i<L&&h[i-1]<h[i+1]?(m=(g=h[i+1])-D-n,g<p&&y.MarkNextChange(),p=g,y.AddModifiedElement(g+1,m),D=i+1-t):(m=(g=h[i-1]+1)-D-n,g<p&&y.MarkNextChange(),p=g-1,y.AddOriginalElement(g,m+1),D=i-1-t),M>=0&&(t=(h=this.m_forwardHistory[M])[0],A=1,L=h.length-1)}while(--M>=-1);if(E=y.getReverseChanges(),_[0]){let t=f[0]+1,i=c[0]+1;if(null!==E&&E.length>0){const e=E[E.length-1];t=Math.max(t,e.getOriginalEnd()),i=Math.max(i,e.getModifiedEnd())}C=[new DiffChange(t,d-t+1,i,u-i+1)]}else{y=new DiffChangeHelper,A=s,L=o,D=f[0]-c[0]-a,p=1073741824,M=S?this.m_reverseHistory.length-1:this.m_reverseHistory.length-2;do{const t=D+r;t===A||t<L&&l[t-1]>=l[t+1]?(m=(g=l[t+1]-1)-D-a,g>p&&y.MarkNextChange(),p=g+1,y.AddOriginalElement(g+1,m+1),D=t+1-r):(m=(g=l[t-1])-D-a,g>p&&y.MarkNextChange(),p=g,y.AddModifiedElement(g+1,m+1),D=t-1-r),M>=0&&(r=(l=this.m_reverseHistory[M])[0],A=1,L=l.length-1)}while(--M>=-1);C=y.getChanges()}return this.ConcatenateChanges(E,C)}ComputeRecursionPoint(t,i,e,n,r,s,o){let a=0,h=0,l=0,g=0,d=0,f=0;t--,e--,r[0]=0,s[0]=0,this.m_forwardHistory=[],this.m_reverseHistory=[];const m=i-t+(n-e),u=m+1,c=new Int32Array(u),S=new Int32Array(u),_=n-e,E=i-t,C=t-e,y=i-n,A=(E-_)%2==0;c[_]=t,S[E]=i,o[0]=!1;for(let L=1;L<=m/2+1;L++){let m=0,D=0;l=this.ClipDiagonalBound(_-L,L,_,u),g=this.ClipDiagonalBound(_+L,L,_,u);for(let t=l;t<=g;t+=2){a=t===l||t<g&&c[t-1]<c[t+1]?c[t+1]:c[t-1]+1,h=a-(t-_)-C;const e=a;for(;a<i&&h<n&&this.ElementsAreEqual(a+1,h+1);)a++,h++;if(c[t]=a,a+h>m+D&&(m=a,D=h),!A&&Math.abs(t-E)<=L-1&&a>=S[t])return r[0]=a,s[0]=h,e<=S[t]&&L<=1448?this.WALKTRACE(_,l,g,C,E,d,f,y,c,S,a,i,r,h,n,s,A,o):null}const p=(m-t+(D-e)-L)/2;if(null!==this.ContinueProcessingPredicate&&!this.ContinueProcessingPredicate(m,p))return o[0]=!0,r[0]=m,s[0]=D,p>0&&L<=1448?this.WALKTRACE(_,l,g,C,E,d,f,y,c,S,a,i,r,h,n,s,A,o):(t++,e++,[new DiffChange(t,i-t+1,e,n-e+1)]);d=this.ClipDiagonalBound(E-L,L,E,u),f=this.ClipDiagonalBound(E+L,L,E,u);for(let m=d;m<=f;m+=2){a=m===d||m<f&&S[m-1]>=S[m+1]?S[m+1]-1:S[m-1],h=a-(m-E)-y;const u=a;for(;a>t&&h>e&&this.ElementsAreEqual(a,h);)a--,h--;if(S[m]=a,A&&Math.abs(m-_)<=L&&a<=c[m])return r[0]=a,s[0]=h,u>=c[m]&&L<=1448?this.WALKTRACE(_,l,g,C,E,d,f,y,c,S,a,i,r,h,n,s,A,o):null}if(L<=1447){let t=new Int32Array(g-l+2);t[0]=_-l+1,MyArray.Copy2(c,l,t,1,g-l+1),this.m_forwardHistory.push(t),t=new Int32Array(f-d+2),t[0]=E-d+1,MyArray.Copy2(S,d,t,1,f-d+1),this.m_reverseHistory.push(t)}}return this.WALKTRACE(_,l,g,C,E,d,f,y,c,S,a,i,r,h,n,s,A,o)}PrettifyChanges(t){for(let i=0;i<t.length;i++){const e=t[i],n=i<t.length-1?t[i+1].originalStart:this._originalElementsOrHash.length,r=i<t.length-1?t[i+1].modifiedStart:this._modifiedElementsOrHash.length,s=e.originalLength>0,o=e.modifiedLength>0;for(;e.originalStart+e.originalLength<n&&e.modifiedStart+e.modifiedLength<r&&(!s||this.OriginalElementsAreEqual(e.originalStart,e.originalStart+e.originalLength))&&(!o||this.ModifiedElementsAreEqual(e.modifiedStart,e.modifiedStart+e.modifiedLength));){const t=this.ElementsAreStrictEqual(e.originalStart,e.modifiedStart);if(this.ElementsAreStrictEqual(e.originalStart+e.originalLength,e.modifiedStart+e.modifiedLength)&&!t)break;e.originalStart++,e.modifiedStart++}const a=[null];i<t.length-1&&this.ChangesOverlap(t[i],t[i+1],a)&&(t[i]=a[0],t.splice(i+1,1),i--)}for(let i=t.length-1;i>=0;i--){const e=t[i];let n=0,r=0;if(i>0){const e=t[i-1];n=e.originalStart+e.originalLength,r=e.modifiedStart+e.modifiedLength}const s=e.originalLength>0,o=e.modifiedLength>0;let a=0,h=this._boundaryScore(e.originalStart,e.originalLength,e.modifiedStart,e.modifiedLength);for(let t=1;;t++){const i=e.originalStart-t,l=e.modifiedStart-t;if(i<n||l<r)break;if(s&&!this.OriginalElementsAreEqual(i,i+e.originalLength))break;if(o&&!this.ModifiedElementsAreEqual(l,l+e.modifiedLength))break;const g=(i===n&&l===r?5:0)+this._boundaryScore(i,e.originalLength,l,e.modifiedLength);g>h&&(h=g,a=t)}e.originalStart-=a,e.modifiedStart-=a;const l=[null];i>0&&this.ChangesOverlap(t[i-1],t[i],l)&&(t[i-1]=l[0],t.splice(i,1),i++)}if(this._hasStrings)for(let i=1,e=t.length;i<e;i++){const e=t[i-1],n=t[i],r=n.originalStart-e.originalStart-e.originalLength,s=e.originalStart,o=n.originalStart+n.originalLength,a=o-s,h=e.modifiedStart,l=n.modifiedStart+n.modifiedLength,g=l-h;if(r<5&&a<20&&g<20){const t=this._findBetterContiguousSequence(s,a,h,g,r);if(t){const[i,s]=t;i===e.originalStart+e.originalLength&&s===e.modifiedStart+e.modifiedLength||(e.originalLength=i-e.originalStart,e.modifiedLength=s-e.modifiedStart,n.originalStart=i+r,n.modifiedStart=s+r,n.originalLength=o-n.originalStart,n.modifiedLength=l-n.modifiedStart)}}}return t}_findBetterContiguousSequence(t,i,e,n,r){if(i<r||n<r)return null;const s=t+i-r+1,o=e+n-r+1;let a=0,h=0,l=0;for(let i=t;i<s;i++)for(let t=e;t<o;t++){const e=this._contiguousSequenceScore(i,t,r);e>0&&e>a&&(a=e,h=i,l=t)}return a>0?[h,l]:null}_contiguousSequenceScore(t,i,e){let n=0;for(let r=0;r<e;r++){if(!this.ElementsAreEqual(t+r,i+r))return 0;n+=this._originalStringElements[t+r].length}return n}_OriginalIsBoundary(t){return t<=0||t>=this._originalElementsOrHash.length-1||this._hasStrings&&/^\s*$/.test(this._originalStringElements[t])}_OriginalRegionIsBoundary(t,i){if(this._OriginalIsBoundary(t)||this._OriginalIsBoundary(t-1))return!0;if(i>0){const e=t+i;if(this._OriginalIsBoundary(e-1)||this._OriginalIsBoundary(e))return!0}return!1}_ModifiedIsBoundary(t){return t<=0||t>=this._modifiedElementsOrHash.length-1||this._hasStrings&&/^\s*$/.test(this._modifiedStringElements[t])}_ModifiedRegionIsBoundary(t,i){if(this._ModifiedIsBoundary(t)||this._ModifiedIsBoundary(t-1))return!0;if(i>0){const e=t+i;if(this._ModifiedIsBoundary(e-1)||this._ModifiedIsBoundary(e))return!0}return!1}_boundaryScore(t,i,e,n){return(this._OriginalRegionIsBoundary(t,i)?1:0)+(this._ModifiedRegionIsBoundary(e,n)?1:0)}ConcatenateChanges(t,i){const e=[];if(0===t.length||0===i.length)return i.length>0?i:t;if(this.ChangesOverlap(t[t.length-1],i[0],e)){const n=new Array(t.length+i.length-1);return MyArray.Copy(t,0,n,0,t.length-1),n[t.length-1]=e[0],MyArray.Copy(i,1,n,t.length,i.length-1),n}{const e=new Array(t.length+i.length);return MyArray.Copy(t,0,e,0,t.length),MyArray.Copy(i,0,e,t.length,i.length),e}}ChangesOverlap(t,i,e){if(Debug.Assert(t.originalStart<=i.originalStart,"Left change is not less than or equal to right change"),Debug.Assert(t.modifiedStart<=i.modifiedStart,"Left change is not less than or equal to right change"),t.originalStart+t.originalLength>=i.originalStart||t.modifiedStart+t.modifiedLength>=i.modifiedStart){const n=t.originalStart;let r=t.originalLength;const s=t.modifiedStart;let o=t.modifiedLength;return t.originalStart+t.originalLength>=i.originalStart&&(r=i.originalStart+i.originalLength-t.originalStart),t.modifiedStart+t.modifiedLength>=i.modifiedStart&&(o=i.modifiedStart+i.modifiedLength-t.modifiedStart),e[0]=new DiffChange(n,r,s,o),!0}return e[0]=null,!1}ClipDiagonalBound(t,i,e,n){if(t>=0&&t<n)return t;const r=i%2==0;return t<0?r===(e%2==0)?0:1:r===((n-e-1)%2==0)?n-1:n-2}}