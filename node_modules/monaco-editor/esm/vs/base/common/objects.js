import{isTypedArray,isObject,isUndefinedOrNull}from"./types.js";export function deepClone(e){if(!e||"object"!=typeof e)return e;if(e instanceof RegExp)return e;const t=Array.isArray(e)?[]:{};return Object.entries(e).forEach((([e,r])=>{t[e]=r&&"object"==typeof r?deepClone(r):r})),t}export function deepFreeze(e){if(!e||"object"!=typeof e)return e;const t=[e];for(;t.length>0;){const e=t.shift();Object.freeze(e);for(const r in e)if(_hasOwnProperty.call(e,r)){const n=e[r];"object"!=typeof n||Object.isFrozen(n)||isTypedArray(n)||t.push(n)}}return e}const _hasOwnProperty=Object.prototype.hasOwnProperty;export function cloneAndChange(e,t){return _cloneAndChange(e,t,new Set)}function _cloneAndChange(e,t,r){if(isUndefinedOrNull(e))return e;const n=t(e);if(void 0!==n)return n;if(Array.isArray(e)){const n=[];for(const o of e)n.push(_cloneAndChange(o,t,r));return n}if(isObject(e)){if(r.has(e))throw new Error("Cannot clone recursive data-structure");r.add(e);const n={};for(const o in e)_hasOwnProperty.call(e,o)&&(n[o]=_cloneAndChange(e[o],t,r));return r.delete(e),n}return e}export function mixin(e,t,r=!0){return isObject(e)?(isObject(t)&&Object.keys(t).forEach((n=>{n in e?r&&(isObject(e[n])&&isObject(t[n])?mixin(e[n],t[n],r):e[n]=t[n]):e[n]=t[n]})),e):t}export function equals(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(typeof e!=typeof t)return!1;if("object"!=typeof e)return!1;if(Array.isArray(e)!==Array.isArray(t))return!1;let r,n;if(Array.isArray(e)){if(e.length!==t.length)return!1;for(r=0;r<e.length;r++)if(!equals(e[r],t[r]))return!1}else{const o=[];for(n in e)o.push(n);o.sort();const c=[];for(n in t)c.push(n);if(c.sort(),!equals(o,c))return!1;for(r=0;r<o.length;r++)if(!equals(e[o[r]],t[o[r]]))return!1}return!0}export function getAllPropertyNames(e){let t=[],r=Object.getPrototypeOf(e);for(;Object.prototype!==r;)t=t.concat(Object.getOwnPropertyNames(r)),r=Object.getPrototypeOf(r);return t}export function getAllMethodNames(e){const t=[];for(const r of getAllPropertyNames(e))"function"==typeof e[r]&&t.push(r);return t}export function createProxyObject(e,t){const r=e=>function(){const r=Array.prototype.slice.call(arguments,0);return t(e,r)},n={};for(const t of e)n[t]=r(t);return n}