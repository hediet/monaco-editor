import{onUnexpectedError}from"./errors.js";import{once as onceFn}from"./functional.js";import{combinedDisposable,Disposable,DisposableStore,SafeDisposable,toDisposable}from"./lifecycle.js";import{LinkedList}from"./linkedList.js";import{StopWatch}from"./stopwatch.js";const _enableDisposeWithListenerWarning=!1,_enableSnapshotPotentialLeakWarning=!1;export var Event;!function(e){function t(e){return(t,s=null,i)=>{let n,r=!1;return n=e((e=>{if(!r)return n?n.dispose():r=!0,t.call(s,e)}),null,i),r&&n.dispose(),n}}function s(e,t,s){return o(((s,i=null,n)=>e((e=>s.call(i,t(e))),null,n)),s)}function i(e,t,s){return o(((s,i=null,n)=>e((e=>{t(e),s.call(i,e)}),null,n)),s)}function n(e,t,s){return o(((s,i=null,n)=>e((e=>t(e)&&s.call(i,e)),null,n)),s)}function r(e,t,i,n){let r=i;return s(e,(e=>(r=t(r,e),r)),n)}function o(e,t){let s;const i=new Emitter({onWillAddFirstListener(){s=e(i.fire,i)},onDidRemoveLastListener(){null==s||s.dispose()}});return null==t||t.add(i),i.event}function l(e,t,s=100,i=!1,n,r){let o,l,h,u=0;const a=new Emitter({leakWarningThreshold:n,onWillAddFirstListener(){o=e((e=>{u++,l=t(l,e),i&&!h&&(a.fire(l),l=void 0);const n=()=>{const e=l;l=void 0,h=void 0,(!i||u>1)&&a.fire(e),u=0};"number"==typeof s?(clearTimeout(h),h=setTimeout(n,s)):void 0===h&&(h=0,queueMicrotask(n))}))},onDidRemoveLastListener(){o.dispose()}});return null==r||r.add(a),a.event}function h(e,t=((e,t)=>e===t),s){let i,r=!0;return n(e,(e=>{const s=r||!t(e,i);return r=!1,i=e,s}),s)}e.None=()=>Disposable.None,e.defer=function(e,t){return l(e,(()=>{}),0,void 0,void 0,t)},e.once=t,e.map=s,e.forEach=i,e.filter=n,e.signal=function(e){return e},e.any=function(...e){return(t,s=null,i)=>combinedDisposable(...e.map((e=>e((e=>t.call(s,e)),null,i))))},e.reduce=r,e.debounce=l,e.accumulate=function(t,s=0,i){return e.debounce(t,((e,t)=>e?(e.push(t),e):[t]),s,void 0,void 0,i)},e.latch=h,e.split=function(t,s,i){return[e.filter(t,s,i),e.filter(t,(e=>!s(e)),i)]},e.buffer=function(e,t=!1,s=[]){let i=s.slice(),n=e((e=>{i?i.push(e):o.fire(e)}));const r=()=>{null==i||i.forEach((e=>o.fire(e))),i=null},o=new Emitter({onWillAddFirstListener(){n||(n=e((e=>o.fire(e))))},onDidAddFirstListener(){i&&(t?setTimeout(r):r())},onDidRemoveLastListener(){n&&n.dispose(),n=null}});return o.event};class u{constructor(e){this.event=e,this.disposables=new DisposableStore}map(e){return new u(s(this.event,e,this.disposables))}forEach(e){return new u(i(this.event,e,this.disposables))}filter(e){return new u(n(this.event,e,this.disposables))}reduce(e,t){return new u(r(this.event,e,t,this.disposables))}latch(){return new u(h(this.event,void 0,this.disposables))}debounce(e,t=100,s=!1,i){return new u(l(this.event,e,t,s,i,this.disposables))}on(e,t,s){return this.event(e,t,s)}once(e,s,i){return t(this.event)(e,s,i)}dispose(){this.disposables.dispose()}}e.chain=function(e){return new u(e)},e.fromNodeEventEmitter=function(e,t,s=(e=>e)){const i=(...e)=>n.fire(s(...e)),n=new Emitter({onWillAddFirstListener:()=>e.on(t,i),onDidRemoveLastListener:()=>e.removeListener(t,i)});return n.event},e.fromDOMEventEmitter=function(e,t,s=(e=>e)){const i=(...e)=>n.fire(s(...e)),n=new Emitter({onWillAddFirstListener:()=>e.addEventListener(t,i),onDidRemoveLastListener:()=>e.removeEventListener(t,i)});return n.event},e.toPromise=function(e){return new Promise((s=>t(e)(s)))},e.runAndSubscribe=function(e,t){return t(void 0),e((e=>t(e)))},e.runAndSubscribeWithStore=function(e,t){let s=null;function i(e){null==s||s.dispose(),s=new DisposableStore,t(e,s)}i(void 0);const n=e((e=>i(e)));return toDisposable((()=>{n.dispose(),null==s||s.dispose()}))};class a{constructor(e,t){this.obs=e,this._counter=0,this._hasChanged=!1;const s={onWillAddFirstListener:()=>{e.addObserver(this)},onDidRemoveLastListener:()=>{e.removeObserver(this)}};this.emitter=new Emitter(s),t&&t.add(this.emitter)}beginUpdate(e){this._counter++}handleChange(e,t){this._hasChanged=!0}endUpdate(e){0==--this._counter&&this._hasChanged&&(this._hasChanged=!1,this.emitter.fire(this.obs.get()))}}e.fromObservable=function(e,t){return new a(e,t).emitter.event}}(Event||(Event={}));class EventProfiling{constructor(e){this.listenerCount=0,this.invocationCount=0,this.elapsedOverall=0,this.durations=[],this.name=`${e}_${EventProfiling._idPool++}`,EventProfiling.all.add(this)}start(e){this._stopWatch=new StopWatch(!0),this.listenerCount=e}stop(){if(this._stopWatch){const e=this._stopWatch.elapsed();this.durations.push(e),this.elapsedOverall+=e,this.invocationCount+=1,this._stopWatch=void 0}}}EventProfiling.all=new Set,EventProfiling._idPool=0;export{EventProfiling};let _globalLeakWarningThreshold=-1;class LeakageMonitor{constructor(e,t=Math.random().toString(18).slice(2,5)){this.threshold=e,this.name=t,this._warnCountdown=0}dispose(){var e;null===(e=this._stacks)||void 0===e||e.clear()}check(e,t){const s=this.threshold;if(s<=0||t<s)return;this._stacks||(this._stacks=new Map);const i=this._stacks.get(e.value)||0;if(this._stacks.set(e.value,i+1),this._warnCountdown-=1,this._warnCountdown<=0){let e;this._warnCountdown=.5*s;let i=0;for(const[t,s]of this._stacks)(!e||i<s)&&(e=t,i=s);console.warn(`[${this.name}] potential listener LEAK detected, having ${t} listeners already. MOST frequent listener (${i}):`),console.warn(e)}return()=>{const t=this._stacks.get(e.value)||0;this._stacks.set(e.value,t-1)}}}class Stacktrace{static create(){var e;return new Stacktrace(null!==(e=(new Error).stack)&&void 0!==e?e:"")}constructor(e){this.value=e}print(){console.warn(this.value.split("\n").slice(2).join("\n"))}}class Listener{constructor(e,t,s){this.callback=e,this.callbackThis=t,this.stack=s,this.subscription=new SafeDisposable}invoke(e){this.callback.call(this.callbackThis,e)}}export class Emitter{constructor(e){var t,s,i,n,r;this._disposed=!1,this._options=e,this._leakageMon=_globalLeakWarningThreshold>0||(null===(t=this._options)||void 0===t?void 0:t.leakWarningThreshold)?new LeakageMonitor(null!==(i=null===(s=this._options)||void 0===s?void 0:s.leakWarningThreshold)&&void 0!==i?i:_globalLeakWarningThreshold):void 0,this._perfMon=(null===(n=this._options)||void 0===n?void 0:n._profName)?new EventProfiling(this._options._profName):void 0,this._deliveryQueue=null===(r=this._options)||void 0===r?void 0:r.deliveryQueue}dispose(){var e,t,s,i;this._disposed||(this._disposed=!0,this._listeners&&this._listeners.clear(),null===(e=this._deliveryQueue)||void 0===e||e.clear(this),null===(s=null===(t=this._options)||void 0===t?void 0:t.onDidRemoveLastListener)||void 0===s||s.call(t),null===(i=this._leakageMon)||void 0===i||i.dispose())}get event(){return this._event||(this._event=(e,t,s)=>{var i,n,r;if(this._listeners||(this._listeners=new LinkedList),this._leakageMon&&this._listeners.size>3*this._leakageMon.threshold)return console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`),Disposable.None;const o=this._listeners.isEmpty();let l,h;o&&(null===(i=this._options)||void 0===i?void 0:i.onWillAddFirstListener)&&this._options.onWillAddFirstListener(this),this._leakageMon&&this._listeners.size>=Math.ceil(.2*this._leakageMon.threshold)&&(h=Stacktrace.create(),l=this._leakageMon.check(h,this._listeners.size+1));const u=new Listener(e,t,h),a=this._listeners.push(u);o&&(null===(n=this._options)||void 0===n?void 0:n.onDidAddFirstListener)&&this._options.onDidAddFirstListener(this),(null===(r=this._options)||void 0===r?void 0:r.onDidAddListener)&&this._options.onDidAddListener(this,e,t);const d=u.subscription.set((()=>{null==l||l(),!this._disposed&&(a(),this._options&&this._options.onDidRemoveLastListener)&&(this._listeners&&!this._listeners.isEmpty()||this._options.onDidRemoveLastListener(this))}));return s instanceof DisposableStore?s.add(d):Array.isArray(s)&&s.push(d),d}),this._event}fire(e){var t,s;if(this._listeners){this._deliveryQueue||(this._deliveryQueue=new PrivateEventDeliveryQueue);for(const t of this._listeners)this._deliveryQueue.push(this,t,e);null===(t=this._perfMon)||void 0===t||t.start(this._deliveryQueue.size),this._deliveryQueue.deliver(),null===(s=this._perfMon)||void 0===s||s.stop()}}hasListeners(){return!!this._listeners&&!this._listeners.isEmpty()}}export class EventDeliveryQueue{constructor(){this._queue=new LinkedList}get size(){return this._queue.size}push(e,t,s){this._queue.push(new EventDeliveryQueueElement(e,t,s))}clear(e){const t=new LinkedList;for(const s of this._queue)s.emitter!==e&&t.push(s);this._queue=t}deliver(){for(;this._queue.size>0;){const e=this._queue.shift();try{e.listener.invoke(e.event)}catch(e){onUnexpectedError(e)}}}}class PrivateEventDeliveryQueue extends EventDeliveryQueue{clear(e){this._queue.clear()}}class EventDeliveryQueueElement{constructor(e,t,s){this.emitter=e,this.listener=t,this.event=s}}export class PauseableEmitter extends Emitter{constructor(e){super(e),this._isPaused=0,this._eventQueue=new LinkedList,this._mergeFn=null==e?void 0:e.merge}pause(){this._isPaused++}resume(){if(0!==this._isPaused&&0==--this._isPaused)if(this._mergeFn){if(this._eventQueue.size>0){const e=Array.from(this._eventQueue);this._eventQueue.clear(),super.fire(this._mergeFn(e))}}else for(;!this._isPaused&&0!==this._eventQueue.size;)super.fire(this._eventQueue.shift())}fire(e){this._listeners&&(0!==this._isPaused?this._eventQueue.push(e):super.fire(e))}}export class DebounceEmitter extends PauseableEmitter{constructor(e){var t;super(e),this._delay=null!==(t=e.delay)&&void 0!==t?t:100}fire(e){this._handle||(this.pause(),this._handle=setTimeout((()=>{this._handle=void 0,this.resume()}),this._delay)),super.fire(e)}}export class MicrotaskEmitter extends Emitter{constructor(e){super(e),this._queuedEvents=[],this._mergeFn=null==e?void 0:e.merge}fire(e){this.hasListeners()&&(this._queuedEvents.push(e),1===this._queuedEvents.length&&queueMicrotask((()=>{this._mergeFn?super.fire(this._mergeFn(this._queuedEvents)):this._queuedEvents.forEach((e=>super.fire(e))),this._queuedEvents=[]})))}}export class EventMultiplexer{constructor(){this.hasListeners=!1,this.events=[],this.emitter=new Emitter({onWillAddFirstListener:()=>this.onFirstListenerAdd(),onDidRemoveLastListener:()=>this.onLastListenerRemove()})}get event(){return this.emitter.event}add(e){const t={event:e,listener:null};return this.events.push(t),this.hasListeners&&this.hook(t),toDisposable(onceFn((()=>{this.hasListeners&&this.unhook(t);const e=this.events.indexOf(t);this.events.splice(e,1)})))}onFirstListenerAdd(){this.hasListeners=!0,this.events.forEach((e=>this.hook(e)))}onLastListenerRemove(){this.hasListeners=!1,this.events.forEach((e=>this.unhook(e)))}hook(e){e.listener=e.event((e=>this.emitter.fire(e)))}unhook(e){e.listener&&e.listener.dispose(),e.listener=null}dispose(){this.emitter.dispose()}}export class EventBufferer{constructor(){this.buffers=[]}wrapEvent(e){return(t,s,i)=>e((e=>{const i=this.buffers[this.buffers.length-1];i?i.push((()=>t.call(s,e))):t.call(s,e)}),void 0,i)}bufferEvents(e){const t=[];this.buffers.push(t);const s=e();return this.buffers.pop(),t.forEach((e=>e())),s}}export class Relay{constructor(){this.listening=!1,this.inputEvent=Event.None,this.inputEventListener=Disposable.None,this.emitter=new Emitter({onDidAddFirstListener:()=>{this.listening=!0,this.inputEventListener=this.inputEvent(this.emitter.fire,this.emitter)},onDidRemoveLastListener:()=>{this.listening=!1,this.inputEventListener.dispose()}}),this.event=this.emitter.event}set input(e){this.inputEvent=e,this.listening&&(this.inputEventListener.dispose(),this.inputEventListener=e(this.emitter.fire,this.emitter))}dispose(){this.inputEventListener.dispose(),this.emitter.dispose()}}