var __awaiter=this&&this.__awaiter||function(e,t,i,r){return new(i||(i=Promise))((function(s,n){function o(e){try{a(r.next(e))}catch(e){n(e)}}function l(e){try{a(r.throw(e))}catch(e){n(e)}}function a(e){var t;e.done?s(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(o,l)}a((r=r.apply(e,t||[])).next())}))},__asyncValues=this&&this.__asyncValues||function(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,i=e[Symbol.asyncIterator];return i?i.call(e):(e="function"==typeof __values?__values(e):e[Symbol.iterator](),t={},r("next"),r("throw"),r("return"),t[Symbol.asyncIterator]=function(){return this},t);function r(i){t[i]=e[i]&&function(t){return new Promise((function(r,s){!function(e,t,i,r){Promise.resolve(r).then((function(t){e({value:t,done:i})}),t)}(r,s,(t=e[i](t)).done,t.value)}))}}};import{CancellationTokenSource}from"./cancellation.js";import{CancellationError}from"./errors.js";import{Emitter,Event}from"./event.js";import{toDisposable}from"./lifecycle.js";import{setTimeout0}from"./platform.js";import{MicrotaskDelay}from"./symbols.js";export function isThenable(e){return!!e&&"function"==typeof e.then}export function createCancelablePromise(e){const t=new CancellationTokenSource,i=e(t.token),r=new Promise(((e,r)=>{const s=t.token.onCancellationRequested((()=>{s.dispose(),t.dispose(),r(new CancellationError)}));Promise.resolve(i).then((i=>{s.dispose(),t.dispose(),e(i)}),(e=>{s.dispose(),t.dispose(),r(e)}))}));return new class{cancel(){t.cancel()}then(e,t){return r.then(e,t)}catch(e){return this.then(void 0,e)}finally(e){return r.finally(e)}}}export function raceCancellation(e,t,i){return new Promise(((r,s)=>{const n=t.onCancellationRequested((()=>{n.dispose(),r(i)}));e.then(r,s).finally((()=>n.dispose()))}))}export class Throttler{constructor(){this.activePromise=null,this.queuedPromise=null,this.queuedPromiseFactory=null}queue(e){if(this.activePromise){if(this.queuedPromiseFactory=e,!this.queuedPromise){const e=()=>{this.queuedPromise=null;const e=this.queue(this.queuedPromiseFactory);return this.queuedPromiseFactory=null,e};this.queuedPromise=new Promise((t=>{this.activePromise.then(e,e).then(t)}))}return new Promise(((e,t)=>{this.queuedPromise.then(e,t)}))}return this.activePromise=e(),new Promise(((e,t)=>{this.activePromise.then((t=>{this.activePromise=null,e(t)}),(e=>{this.activePromise=null,t(e)}))}))}}const timeoutDeferred=(e,t)=>{let i=!0;const r=setTimeout((()=>{i=!1,t()}),e);return{isTriggered:()=>i,dispose:()=>{clearTimeout(r),i=!1}}},microtaskDeferred=e=>{let t=!0;return queueMicrotask((()=>{t&&(t=!1,e())})),{isTriggered:()=>t,dispose:()=>{t=!1}}};export class Delayer{constructor(e){this.defaultDelay=e,this.deferred=null,this.completionPromise=null,this.doResolve=null,this.doReject=null,this.task=null}trigger(e,t=this.defaultDelay){this.task=e,this.cancelTimeout(),this.completionPromise||(this.completionPromise=new Promise(((e,t)=>{this.doResolve=e,this.doReject=t})).then((()=>{if(this.completionPromise=null,this.doResolve=null,this.task){const e=this.task;return this.task=null,e()}})));const i=()=>{var e;this.deferred=null,null===(e=this.doResolve)||void 0===e||e.call(this,null)};return this.deferred=t===MicrotaskDelay?microtaskDeferred(i):timeoutDeferred(t,i),this.completionPromise}isTriggered(){var e;return!!(null===(e=this.deferred)||void 0===e?void 0:e.isTriggered())}cancel(){var e;this.cancelTimeout(),this.completionPromise&&(null===(e=this.doReject)||void 0===e||e.call(this,new CancellationError),this.completionPromise=null)}cancelTimeout(){var e;null===(e=this.deferred)||void 0===e||e.dispose(),this.deferred=null}dispose(){this.cancel()}}export class ThrottledDelayer{constructor(e){this.delayer=new Delayer(e),this.throttler=new Throttler}trigger(e,t){return this.delayer.trigger((()=>this.throttler.queue(e)),t)}dispose(){this.delayer.dispose()}}export function timeout(e,t){return t?new Promise(((i,r)=>{const s=setTimeout((()=>{n.dispose(),i()}),e),n=t.onCancellationRequested((()=>{clearTimeout(s),n.dispose(),r(new CancellationError)}))})):createCancelablePromise((t=>timeout(e,t)))}export function disposableTimeout(e,t=0){const i=setTimeout(e,t);return toDisposable((()=>clearTimeout(i)))}export function first(e,t=(e=>!!e),i=null){let r=0;const s=e.length,n=()=>{if(r>=s)return Promise.resolve(i);const o=e[r++];return Promise.resolve(o()).then((e=>t(e)?Promise.resolve(e):n()))};return n()}export class TimeoutTimer{constructor(e,t){this._token=-1,"function"==typeof e&&"number"==typeof t&&this.setIfNotSet(e,t)}dispose(){this.cancel()}cancel(){-1!==this._token&&(clearTimeout(this._token),this._token=-1)}cancelAndSet(e,t){this.cancel(),this._token=setTimeout((()=>{this._token=-1,e()}),t)}setIfNotSet(e,t){-1===this._token&&(this._token=setTimeout((()=>{this._token=-1,e()}),t))}}export class IntervalTimer{constructor(){this._token=-1}dispose(){this.cancel()}cancel(){-1!==this._token&&(clearInterval(this._token),this._token=-1)}cancelAndSet(e,t){this.cancel(),this._token=setInterval((()=>{e()}),t)}}export class RunOnceScheduler{constructor(e,t){this.timeoutToken=-1,this.runner=e,this.timeout=t,this.timeoutHandler=this.onTimeout.bind(this)}dispose(){this.cancel(),this.runner=null}cancel(){this.isScheduled()&&(clearTimeout(this.timeoutToken),this.timeoutToken=-1)}schedule(e=this.timeout){this.cancel(),this.timeoutToken=setTimeout(this.timeoutHandler,e)}get delay(){return this.timeout}set delay(e){this.timeout=e}isScheduled(){return-1!==this.timeoutToken}onTimeout(){this.timeoutToken=-1,this.runner&&this.doRun()}doRun(){var e;null===(e=this.runner)||void 0===e||e.call(this)}}export let runWhenIdle;runWhenIdle="function"!=typeof requestIdleCallback||"function"!=typeof cancelIdleCallback?e=>{setTimeout0((()=>{if(t)return;const i=Date.now()+15;e(Object.freeze({didTimeout:!0,timeRemaining:()=>Math.max(0,i-Date.now())}))}));let t=!1;return{dispose(){t||(t=!0)}}}:(e,t)=>{const i=requestIdleCallback(e,"number"==typeof t?{timeout:t}:void 0);let r=!1;return{dispose(){r||(r=!0,cancelIdleCallback(i))}}};export class IdleValue{constructor(e){this._didRun=!1,this._executor=()=>{try{this._value=e()}catch(e){this._error=e}finally{this._didRun=!0}},this._handle=runWhenIdle((()=>this._executor()))}dispose(){this._handle.dispose()}get value(){if(this._didRun||(this._handle.dispose(),this._executor()),this._error)throw this._error;return this._value}get isInitialized(){return this._didRun}}export class DeferredPromise{get isRejected(){return this.rejected}get isSettled(){return this.rejected||this.resolved}constructor(){this.rejected=!1,this.resolved=!1,this.p=new Promise(((e,t)=>{this.completeCallback=e,this.errorCallback=t}))}complete(e){return new Promise((t=>{this.completeCallback(e),this.resolved=!0,t()}))}cancel(){new Promise((e=>{this.errorCallback(new CancellationError),this.rejected=!0,e()}))}}export var Promises;!function(e){e.settled=function(e){return __awaiter(this,void 0,void 0,(function*(){let t;const i=yield Promise.all(e.map((e=>e.then((e=>e),(e=>{t||(t=e)})))));if(void 0!==t)throw t;return i}))},e.withAsyncBody=function(e){return new Promise(((t,i)=>__awaiter(this,void 0,void 0,(function*(){try{yield e(t,i)}catch(e){i(e)}}))))}}(Promises||(Promises={}));class AsyncIterableObject{static fromArray(e){return new AsyncIterableObject((t=>{t.emitMany(e)}))}static fromPromise(e){return new AsyncIterableObject((t=>__awaiter(this,void 0,void 0,(function*(){t.emitMany(yield e)}))))}static fromPromises(e){return new AsyncIterableObject((t=>__awaiter(this,void 0,void 0,(function*(){yield Promise.all(e.map((e=>__awaiter(this,void 0,void 0,(function*(){return t.emitOne(yield e)})))))}))))}static merge(e){return new AsyncIterableObject((t=>__awaiter(this,void 0,void 0,(function*(){yield Promise.all(e.map((e=>{var i,r,s;return __awaiter(this,void 0,void 0,(function*(){var n,o,l,a;try{for(i=!0,r=__asyncValues(e);!(n=(s=yield r.next()).done);){a=s.value,i=!1;try{const e=a;t.emitOne(e)}finally{i=!0}}}catch(e){o={error:e}}finally{try{i||n||!(l=r.return)||(yield l.call(r))}finally{if(o)throw o.error}}}))})))}))))}constructor(e){this._state=0,this._results=[],this._error=null,this._onStateChanged=new Emitter,queueMicrotask((()=>__awaiter(this,void 0,void 0,(function*(){const t={emitOne:e=>this.emitOne(e),emitMany:e=>this.emitMany(e),reject:e=>this.reject(e)};try{yield Promise.resolve(e(t)),this.resolve()}catch(e){this.reject(e)}finally{t.emitOne=void 0,t.emitMany=void 0,t.reject=void 0}}))))}[Symbol.asyncIterator](){let e=0;return{next:()=>__awaiter(this,void 0,void 0,(function*(){for(;;){if(2===this._state)throw this._error;if(e<this._results.length)return{done:!1,value:this._results[e++]};if(1===this._state)return{done:!0,value:void 0};yield Event.toPromise(this._onStateChanged.event)}}))}}static map(e,t){return new AsyncIterableObject((i=>__awaiter(this,void 0,void 0,(function*(){var r,s,n,o;try{for(var l,a=!0,c=__asyncValues(e);!(r=(l=yield c.next()).done);){o=l.value,a=!1;try{const e=o;i.emitOne(t(e))}finally{a=!0}}}catch(e){s={error:e}}finally{try{a||r||!(n=c.return)||(yield n.call(c))}finally{if(s)throw s.error}}}))))}map(e){return AsyncIterableObject.map(this,e)}static filter(e,t){return new AsyncIterableObject((i=>__awaiter(this,void 0,void 0,(function*(){var r,s,n,o;try{for(var l,a=!0,c=__asyncValues(e);!(r=(l=yield c.next()).done);){o=l.value,a=!1;try{const e=o;t(e)&&i.emitOne(e)}finally{a=!0}}}catch(e){s={error:e}}finally{try{a||r||!(n=c.return)||(yield n.call(c))}finally{if(s)throw s.error}}}))))}filter(e){return AsyncIterableObject.filter(this,e)}static coalesce(e){return AsyncIterableObject.filter(e,(e=>!!e))}coalesce(){return AsyncIterableObject.coalesce(this)}static toPromise(e){var t,i,r,s,n,o,l;return __awaiter(this,void 0,void 0,(function*(){const a=[];try{for(t=!0,i=__asyncValues(e);r=yield i.next(),!(s=r.done);){l=r.value,t=!1;try{const e=l;a.push(e)}finally{t=!0}}}catch(e){n={error:e}}finally{try{t||s||!(o=i.return)||(yield o.call(i))}finally{if(n)throw n.error}}return a}))}toPromise(){return AsyncIterableObject.toPromise(this)}emitOne(e){0===this._state&&(this._results.push(e),this._onStateChanged.fire())}emitMany(e){0===this._state&&(this._results=this._results.concat(e),this._onStateChanged.fire())}resolve(){0===this._state&&(this._state=1,this._onStateChanged.fire())}reject(e){0===this._state&&(this._state=2,this._error=e,this._onStateChanged.fire())}}AsyncIterableObject.EMPTY=AsyncIterableObject.fromArray([]);export{AsyncIterableObject};export class CancelableAsyncIterableObject extends AsyncIterableObject{constructor(e,t){super(t),this._source=e}cancel(){this._source.cancel()}}export function createCancelableAsyncIterable(e){const t=new CancellationTokenSource,i=e(t.token);return new CancelableAsyncIterableObject(t,(e=>__awaiter(this,void 0,void 0,(function*(){var r,s,n,o;const l=t.token.onCancellationRequested((()=>{l.dispose(),t.dispose(),e.reject(new CancellationError)}));try{try{for(var a,c=!0,u=__asyncValues(i);!(r=(a=yield u.next()).done);){o=a.value,c=!1;try{const i=o;if(t.token.isCancellationRequested)return;e.emitOne(i)}finally{c=!0}}}catch(e){s={error:e}}finally{try{c||r||!(n=u.return)||(yield n.call(u))}finally{if(s)throw s.error}}l.dispose(),t.dispose()}catch(i){l.dispose(),t.dispose(),e.reject(i)}}))))}