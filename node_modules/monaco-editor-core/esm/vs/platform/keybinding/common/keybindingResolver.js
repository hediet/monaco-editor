import{implies,expressionsAreEqualWithConstantSubstitution}from"../../contextkey/common/contextkey.js";export class KeybindingResolver{constructor(e,n,t){this._log=t,this._defaultKeybindings=e,this._defaultBoundCommands=new Map;for(const n of e){const e=n.command;e&&"-"!==e.charAt(0)&&this._defaultBoundCommands.set(e,!0)}this._map=new Map,this._lookupMap=new Map,this._keybindings=KeybindingResolver.handleRemovals([].concat(e).concat(n));for(let e=0,n=this._keybindings.length;e<n;e++){const n=this._keybindings[e];0!==n.keypressParts.length&&(n.when&&0===n.when.type||this._addKeyPress(n.keypressParts[0],n))}}static _isTargetedForRemoval(e,n,t,s){if(n&&e.keypressParts[0]!==n)return!1;if(t&&e.keypressParts[1]!==t)return!1;if(s&&1!==s.type){if(!e.when)return!1;if(!expressionsAreEqualWithConstantSubstitution(s,e.when))return!1}return!0}static handleRemovals(e){const n=new Map;for(let t=0,s=e.length;t<s;t++){const s=e[t];if(s.command&&"-"===s.command.charAt(0)){const e=s.command.substring(1);n.has(e)?n.get(e).push(s):n.set(e,[s])}}if(0===n.size)return e;const t=[];for(let s=0,o=e.length;s<o;s++){const o=e[s];if(!o.command||0===o.command.length){t.push(o);continue}if("-"===o.command.charAt(0))continue;const i=n.get(o.command);if(!i||!o.isDefault){t.push(o);continue}let r=!1;for(const e of i){const n=e.keypressParts[0],t=e.keypressParts[1],s=e.when;if(this._isTargetedForRemoval(o,n,t,s)){r=!0;break}}r||t.push(o)}return t}_addKeyPress(e,n){const t=this._map.get(e);if(void 0===t)return this._map.set(e,[n]),void this._addToLookupMap(n);for(let e=t.length-1;e>=0;e--){const s=t[e];if(s.command===n.command)continue;const o=s.keypressParts.length>1,i=n.keypressParts.length>1;o&&i&&s.keypressParts[1]!==n.keypressParts[1]||KeybindingResolver.whenIsEntirelyIncluded(s.when,n.when)&&this._removeFromLookupMap(s)}t.push(n),this._addToLookupMap(n)}_addToLookupMap(e){if(!e.command)return;let n=this._lookupMap.get(e.command);void 0===n?(n=[e],this._lookupMap.set(e.command,n)):n.push(e)}_removeFromLookupMap(e){if(!e.command)return;const n=this._lookupMap.get(e.command);if(void 0!==n)for(let t=0,s=n.length;t<s;t++)if(n[t]===e)return void n.splice(t,1)}static whenIsEntirelyIncluded(e,n){return!n||1===n.type||!(!e||1===e.type)&&implies(e,n)}getKeybindings(){return this._keybindings}lookupPrimaryKeybinding(e,n){const t=this._lookupMap.get(e);if(void 0===t||0===t.length)return null;if(1===t.length)return t[0];for(let e=t.length-1;e>=0;e--){const s=t[e];if(n.contextMatchesRules(s.when))return s}return t[t.length-1]}resolve(e,n,t){this._log(`| Resolving ${t}${n?` chorded from ${n}`:""}`);let s=null;if(null!==n){const e=this._map.get(n);if(void 0===e)return this._log("\\ No keybinding entries."),null;s=[];for(let n=0,o=e.length;n<o;n++){const o=e[n];o.keypressParts[1]===t&&s.push(o)}}else{const e=this._map.get(t);if(void 0===e)return this._log("\\ No keybinding entries."),null;s=e}const o=this._findCommand(e,s);return o?null===n&&o.keypressParts.length>1&&null!==o.keypressParts[1]?(this._log(`\\ From ${s.length} keybinding entries, matched chord, when: ${printWhenExplanation(o.when)}, source: ${printSourceExplanation(o)}.`),{enterChord:!0,leaveChord:!1,commandId:null,commandArgs:null,bubble:!1}):(this._log(`\\ From ${s.length} keybinding entries, matched ${o.command}, when: ${printWhenExplanation(o.when)}, source: ${printSourceExplanation(o)}.`),{enterChord:!1,leaveChord:o.keypressParts.length>1,commandId:o.command,commandArgs:o.commandArgs,bubble:o.bubble}):(this._log(`\\ From ${s.length} keybinding entries, no when clauses matched the context.`),null)}_findCommand(e,n){for(let t=n.length-1;t>=0;t--){const s=n[t];if(KeybindingResolver._contextMatchesRules(e,s.when))return s}return null}static _contextMatchesRules(e,n){return!n||n.evaluate(e)}}function printWhenExplanation(e){return e?`${e.serialize()}`:"no when condition"}function printSourceExplanation(e){return e.extensionId?e.isBuiltinExtension?`built-in extension ${e.extensionId}`:`user extension ${e.extensionId}`:e.isDefault?"built-in":"user"}