import{assertFn,checkAdjacentItems}from"../../../base/common/assert.js";import{Position}from"../core/position.js";import{Range}from"../core/range.js";import{SequenceFromIntArray,OffsetRange,SequenceDiff}from"./algorithms/diffAlgorithm.js";import{DynamicProgrammingDiffing}from"./algorithms/dynamicProgrammingDiffing.js";import{MyersDiffAlgorithm}from"./algorithms/myersDiffAlgorithm.js";import{LineRange,LineRangeMapping,RangeMapping}from"./linesDiffComputer.js";export class StandardLinesDiffComputer{constructor(){this.dynamicProgrammingDiffing=new DynamicProgrammingDiffing,this.myersDiffingAlgorithm=new MyersDiffAlgorithm}computeDiff(e,n,i){const t=new Map;function r(e){let n=t.get(e);return void 0===n&&(n=t.size,t.set(e,n)),n}const s=e.map((e=>r(e.trim()))),a=n.map((e=>r(e.trim()))),o=new SequenceFromIntArray(s),g=new SequenceFromIntArray(a),f=(()=>o.length+g.length<1500?this.dynamicProgrammingDiffing.compute(o,g,((i,t)=>e[i]===n[t]?0===n[t].length?.1:1+Math.log(1+n[t].length):.99)):this.myersDiffingAlgorithm.compute(o,g))(),m=[],l=i=>{for(let t=0;t<i;t++){const i=c+t,r=u+t;if(e[i]!==n[r]){const t=this.refineDiff(e,n,new SequenceDiff(new OffsetRange(i,i+1),new OffsetRange(r,r+1)));for(const e of t)m.push(e)}}};let c=0,u=0;for(const i of f){assertFn((()=>i.seq1Range.start-c==i.seq2Range.start-u)),l(i.seq1Range.start-c),c=i.seq1Range.endExclusive,u=i.seq2Range.endExclusive;const t=this.refineDiff(e,n,i);for(const e of t)m.push(e)}return l(e.length-c),{quitEarly:!1,changes:lineRangeMappingFromRangeMappings(m)}}refineDiff(e,n,i){const t=new Slice(e,i.seq1Range),r=new Slice(n,i.seq2Range);return this.myersDiffingAlgorithm.compute(t,r).map((e=>new RangeMapping(t.translateRange(e.seq1Range).delta(i.seq1Range.start),r.translateRange(e.seq2Range).delta(i.seq2Range.start))))}}export function lineRangeMappingFromRangeMappings(e){const n=[];for(const i of group(e,((e,n)=>n.originalRange.startLineNumber-(e.originalRange.endLineNumber-(e.originalRange.endColumn>1?0:1))<=1||n.modifiedRange.startLineNumber-(e.modifiedRange.endLineNumber-(e.modifiedRange.endColumn>1?0:1))<=1))){const e=i[0],t=i[i.length-1];n.push(new LineRangeMapping(new LineRange(e.originalRange.startLineNumber,t.originalRange.endLineNumber+(t.originalRange.endColumn>1||t.modifiedRange.endColumn>1?1:0)),new LineRange(e.modifiedRange.startLineNumber,t.modifiedRange.endLineNumber+(t.originalRange.endColumn>1||t.modifiedRange.endColumn>1?1:0)),i))}return assertFn((()=>checkAdjacentItems(n,((e,n)=>n.originalRange.startLineNumber-e.originalRange.endLineNumberExclusive==n.modifiedRange.startLineNumber-e.modifiedRange.endLineNumberExclusive&&e.originalRange.endLineNumberExclusive<n.originalRange.startLineNumber&&e.modifiedRange.endLineNumberExclusive<n.modifiedRange.startLineNumber)))),n}function*group(e,n){let i,t;for(const r of e)void 0!==t&&n(t,r)?i.push(r):(i&&(yield i),i=[r]),t=r;i&&(yield i)}class Slice{constructor(e,n){this.lines=e,this.lineRange=n;let i=0;this.firstCharOnLineOffsets=new Int32Array(n.length);for(let t=n.start;t<n.endExclusive;t++)i+=e[t].length,this.firstCharOnLineOffsets[t-n.start]=i+1,i++;this.elements=new Int32Array(i);let t=0;for(let i=n.start;i<n.endExclusive;i++){const n=e[i];for(let e=0;e<n.length;e++)this.elements[t+e]=n.charCodeAt(e);t+=n.length,i<e.length-1&&(this.elements[t]="\n".charCodeAt(0),t+=1)}}getElement(e){return this.elements[e]}get length(){return this.elements.length}translateOffset(e){let n=0,i=this.firstCharOnLineOffsets.length;for(;n<i;){const t=Math.floor((n+i)/2);this.firstCharOnLineOffsets[t]>e?i=t:n=t+1}const t=0===n?0:this.firstCharOnLineOffsets[n-1];return new Position(n+1,e-t+1)}translateRange(e){return Range.fromPositions(this.translateOffset(e.start),this.translateOffset(e.endExclusive))}}