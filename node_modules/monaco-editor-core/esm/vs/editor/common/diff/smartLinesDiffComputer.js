import{LcsDiff}from"../../../base/common/diff/diff.js";import{LineRange,RangeMapping,LineRangeMapping}from"./linesDiffComputer.js";import*as strings from"../../../base/common/strings.js";import{Range}from"../core/range.js";import{assertFn,checkAdjacentItems}from"../../../base/common/assert.js";const MINIMUM_MATCHING_CHARACTER_LENGTH=3;export class SmartLinesDiffComputer{computeDiff(e,i,n){var t;const r=new DiffComputer(e,i,{maxComputationTime:n.maxComputationTime,shouldIgnoreTrimWhitespace:n.ignoreTrimWhitespace,shouldComputeCharChanges:!0,shouldMakePrettyDiff:!0,shouldPostProcessCharChanges:!0}).computeDiff(),a=[];let o=null;for(const e of r.changes){let i,n;i=0===e.originalEndLineNumber?new LineRange(e.originalStartLineNumber+1,e.originalStartLineNumber+1):new LineRange(e.originalStartLineNumber,e.originalEndLineNumber+1),n=0===e.modifiedEndLineNumber?new LineRange(e.modifiedStartLineNumber+1,e.modifiedStartLineNumber+1):new LineRange(e.modifiedStartLineNumber,e.modifiedEndLineNumber+1);let r=new LineRangeMapping(i,n,null===(t=e.charChanges)||void 0===t?void 0:t.map((e=>new RangeMapping(new Range(e.originalStartLineNumber,e.originalStartColumn,e.originalEndLineNumber,e.originalEndColumn),new Range(e.modifiedStartLineNumber,e.modifiedStartColumn,e.modifiedEndLineNumber,e.modifiedEndColumn)))));o&&(o.modifiedRange.endLineNumberExclusive!==r.modifiedRange.startLineNumber&&o.originalRange.endLineNumberExclusive!==r.originalRange.startLineNumber||(r=new LineRangeMapping(o.originalRange.join(r.originalRange),o.modifiedRange.join(r.modifiedRange),o.innerChanges&&r.innerChanges?o.innerChanges.concat(r.innerChanges):void 0),a.pop())),a.push(r),o=r}return assertFn((()=>checkAdjacentItems(a,((e,i)=>i.originalRange.startLineNumber-e.originalRange.endLineNumberExclusive==i.modifiedRange.startLineNumber-e.modifiedRange.endLineNumberExclusive&&e.originalRange.endLineNumberExclusive<i.originalRange.startLineNumber&&e.modifiedRange.endLineNumberExclusive<i.modifiedRange.startLineNumber)))),{quitEarly:r.quitEarly,changes:a}}}function computeDiff(e,i,n,t){return new LcsDiff(e,i,n).ComputeDiff(t)}class LineSequence{constructor(e){const i=[],n=[];for(let t=0,r=e.length;t<r;t++)i[t]=getFirstNonBlankColumn(e[t],1),n[t]=getLastNonBlankColumn(e[t],1);this.lines=e,this._startColumns=i,this._endColumns=n}getElements(){const e=[];for(let i=0,n=this.lines.length;i<n;i++)e[i]=this.lines[i].substring(this._startColumns[i]-1,this._endColumns[i]-1);return e}getStrictElement(e){return this.lines[e]}getStartLineNumber(e){return e+1}getEndLineNumber(e){return e+1}createCharSequence(e,i,n){const t=[],r=[],a=[];let o=0;for(let s=i;s<=n;s++){const i=this.lines[s],h=e?this._startColumns[s]:1,m=e?this._endColumns[s]:i.length+1;for(let e=h;e<m;e++)t[o]=i.charCodeAt(e-1),r[o]=s+1,a[o]=e,o++;!e&&s<n&&(t[o]=10,r[o]=s+1,a[o]=i.length+1,o++)}return new CharSequence(t,r,a)}}class CharSequence{constructor(e,i,n){this._charCodes=e,this._lineNumbers=i,this._columns=n}toString(){return"["+this._charCodes.map(((e,i)=>(10===e?"\\n":String.fromCharCode(e))+`-(${this._lineNumbers[i]},${this._columns[i]})`)).join(", ")+"]"}_assertIndex(e,i){if(e<0||e>=i.length)throw new Error("Illegal index")}getElements(){return this._charCodes}getStartLineNumber(e){return e>0&&e===this._lineNumbers.length?this.getEndLineNumber(e-1):(this._assertIndex(e,this._lineNumbers),this._lineNumbers[e])}getEndLineNumber(e){return-1===e?this.getStartLineNumber(e+1):(this._assertIndex(e,this._lineNumbers),10===this._charCodes[e]?this._lineNumbers[e]+1:this._lineNumbers[e])}getStartColumn(e){return e>0&&e===this._columns.length?this.getEndColumn(e-1):(this._assertIndex(e,this._columns),this._columns[e])}getEndColumn(e){return-1===e?this.getStartColumn(e+1):(this._assertIndex(e,this._columns),10===this._charCodes[e]?1:this._columns[e]+1)}}class CharChange{constructor(e,i,n,t,r,a,o,s){this.originalStartLineNumber=e,this.originalStartColumn=i,this.originalEndLineNumber=n,this.originalEndColumn=t,this.modifiedStartLineNumber=r,this.modifiedStartColumn=a,this.modifiedEndLineNumber=o,this.modifiedEndColumn=s}static createFromDiffChange(e,i,n){const t=i.getStartLineNumber(e.originalStart),r=i.getStartColumn(e.originalStart),a=i.getEndLineNumber(e.originalStart+e.originalLength-1),o=i.getEndColumn(e.originalStart+e.originalLength-1),s=n.getStartLineNumber(e.modifiedStart),h=n.getStartColumn(e.modifiedStart),m=n.getEndLineNumber(e.modifiedStart+e.modifiedLength-1),g=n.getEndColumn(e.modifiedStart+e.modifiedLength-1);return new CharChange(t,r,a,o,s,h,m,g)}}function postProcessCharChanges(e){if(e.length<=1)return e;const i=[e[0]];let n=i[0];for(let t=1,r=e.length;t<r;t++){const r=e[t],a=r.originalStart-(n.originalStart+n.originalLength),o=r.modifiedStart-(n.modifiedStart+n.modifiedLength);Math.min(a,o)<3?(n.originalLength=r.originalStart+r.originalLength-n.originalStart,n.modifiedLength=r.modifiedStart+r.modifiedLength-n.modifiedStart):(i.push(r),n=r)}return i}class LineChange{constructor(e,i,n,t,r){this.originalStartLineNumber=e,this.originalEndLineNumber=i,this.modifiedStartLineNumber=n,this.modifiedEndLineNumber=t,this.charChanges=r}static createFromDiffResult(e,i,n,t,r,a,o){let s,h,m,g,u;if(0===i.originalLength?(s=n.getStartLineNumber(i.originalStart)-1,h=0):(s=n.getStartLineNumber(i.originalStart),h=n.getEndLineNumber(i.originalStart+i.originalLength-1)),0===i.modifiedLength?(m=t.getStartLineNumber(i.modifiedStart)-1,g=0):(m=t.getStartLineNumber(i.modifiedStart),g=t.getEndLineNumber(i.modifiedStart+i.modifiedLength-1)),a&&i.originalLength>0&&i.originalLength<20&&i.modifiedLength>0&&i.modifiedLength<20&&r()){const a=n.createCharSequence(e,i.originalStart,i.originalStart+i.originalLength-1),s=t.createCharSequence(e,i.modifiedStart,i.modifiedStart+i.modifiedLength-1);if(a.getElements().length>0&&s.getElements().length>0){let e=computeDiff(a,s,r,!0).changes;o&&(e=postProcessCharChanges(e)),u=[];for(let i=0,n=e.length;i<n;i++)u.push(CharChange.createFromDiffChange(e[i],a,s))}}return new LineChange(s,h,m,g,u)}}export class DiffComputer{constructor(e,i,n){this.shouldComputeCharChanges=n.shouldComputeCharChanges,this.shouldPostProcessCharChanges=n.shouldPostProcessCharChanges,this.shouldIgnoreTrimWhitespace=n.shouldIgnoreTrimWhitespace,this.shouldMakePrettyDiff=n.shouldMakePrettyDiff,this.originalLines=e,this.modifiedLines=i,this.original=new LineSequence(e),this.modified=new LineSequence(i),this.continueLineDiff=createContinueProcessingPredicate(n.maxComputationTime),this.continueCharDiff=createContinueProcessingPredicate(0===n.maxComputationTime?0:Math.min(n.maxComputationTime,5e3))}computeDiff(){if(1===this.original.lines.length&&0===this.original.lines[0].length)return 1===this.modified.lines.length&&0===this.modified.lines[0].length?{quitEarly:!1,changes:[]}:{quitEarly:!1,changes:[{originalStartLineNumber:1,originalEndLineNumber:1,modifiedStartLineNumber:1,modifiedEndLineNumber:this.modified.lines.length,charChanges:void 0}]};if(1===this.modified.lines.length&&0===this.modified.lines[0].length)return{quitEarly:!1,changes:[{originalStartLineNumber:1,originalEndLineNumber:this.original.lines.length,modifiedStartLineNumber:1,modifiedEndLineNumber:1,charChanges:void 0}]};const e=computeDiff(this.original,this.modified,this.continueLineDiff,this.shouldMakePrettyDiff),i=e.changes,n=e.quitEarly;if(this.shouldIgnoreTrimWhitespace){const e=[];for(let n=0,t=i.length;n<t;n++)e.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace,i[n],this.original,this.modified,this.continueCharDiff,this.shouldComputeCharChanges,this.shouldPostProcessCharChanges));return{quitEarly:n,changes:e}}const t=[];let r=0,a=0;for(let e=-1,n=i.length;e<n;e++){const o=e+1<n?i[e+1]:null,s=o?o.originalStart:this.originalLines.length,h=o?o.modifiedStart:this.modifiedLines.length;for(;r<s&&a<h;){const e=this.originalLines[r],i=this.modifiedLines[a];if(e!==i){{let n=getFirstNonBlankColumn(e,1),o=getFirstNonBlankColumn(i,1);for(;n>1&&o>1&&e.charCodeAt(n-2)===i.charCodeAt(o-2);)n--,o--;(n>1||o>1)&&this._pushTrimWhitespaceCharChange(t,r+1,1,n,a+1,1,o)}{let n=getLastNonBlankColumn(e,1),o=getLastNonBlankColumn(i,1);const s=e.length+1,h=i.length+1;for(;n<s&&o<h&&e.charCodeAt(n-1)===e.charCodeAt(o-1);)n++,o++;(n<s||o<h)&&this._pushTrimWhitespaceCharChange(t,r+1,n,s,a+1,o,h)}}r++,a++}o&&(t.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace,o,this.original,this.modified,this.continueCharDiff,this.shouldComputeCharChanges,this.shouldPostProcessCharChanges)),r+=o.originalLength,a+=o.modifiedLength)}return{quitEarly:n,changes:t}}_pushTrimWhitespaceCharChange(e,i,n,t,r,a,o){if(this._mergeTrimWhitespaceCharChange(e,i,n,t,r,a,o))return;let s;this.shouldComputeCharChanges&&(s=[new CharChange(i,n,i,t,r,a,r,o)]),e.push(new LineChange(i,i,r,r,s))}_mergeTrimWhitespaceCharChange(e,i,n,t,r,a,o){const s=e.length;if(0===s)return!1;const h=e[s-1];return 0!==h.originalEndLineNumber&&0!==h.modifiedEndLineNumber&&h.originalEndLineNumber+1===i&&h.modifiedEndLineNumber+1===r&&(h.originalEndLineNumber=i,h.modifiedEndLineNumber=r,this.shouldComputeCharChanges&&h.charChanges&&h.charChanges.push(new CharChange(i,n,i,t,r,a,r,o)),!0)}}function getFirstNonBlankColumn(e,i){const n=strings.firstNonWhitespaceIndex(e);return-1===n?i:n+1}function getLastNonBlankColumn(e,i){const n=strings.lastNonWhitespaceIndex(e);return-1===n?i:n+2}function createContinueProcessingPredicate(e){if(0===e)return()=>!0;const i=Date.now();return()=>Date.now()-i<e}